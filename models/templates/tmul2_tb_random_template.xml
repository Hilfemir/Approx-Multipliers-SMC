	<template>
		<name>tmul2_tb_random</name>
		<parameter>const int dly, const double covratio</parameter>
		<declaration>clock x;
clock tcover;
int input=0;
int nsame=0, inSame=0;
double rCover;
int idx=0;

bool inCoverSet[NTV];

int covered()
{
    int cnt=0;

    for(i: int[0,NTV-1])
    {
        if(inCoverSet[i]) {
            cnt++;
        }
    }

    bitsCovered=cnt;

    return cnt;
}

int[0, MAX_INT] bin2dec()
{
    int[0, MAX_INT] result=0;
	int i;
    for(i=0; i&lt;NPI; i++){
        result += bits[i]*TBL_PWR2[i];
    }

    return result;
}


bool inCovered()
{
  return forall (i : int[0,NTV-1]) inCoverSet[i];    
}

void f(int i){
    int j;
    int[0, MAX_INT] imax = fint(exp2(NPI));

//    rnd = random(100);
//    rnd = random_arcsine(-10,10);
//    rnd = random_beta(0.1,5);
//    rnd = random_gamma(0.5,5);
//    rnd = random_normal(10,1);
//    rnd = random_poisson(1.0);
//    rnd = random_weibull(0.5,5);
//    rnd = random_tri(0,10,100);

    j=fint(random(NPI));                   // pro (NPI) je out 0...NPI-1
 //   j=fint(random_normal(NPI/2.0,0.5));    // pro (NPI/2.0, 0.5) je out NPI/2 +- 0.5
 //   j=fint(random_poisson(1.0));           // pro (1.0) je out 1.0 +- 
//    j=fint(random_arcsine(0.0, NPI-1));    // pro (0.0, NPI-1) je out mezi 0...NPI-1 (aka random())
  //  j=fint(random_tri(0.0, 0.5, NPI-1));    // pro (0.0, 0.5, NPI-1) je out mezi 0...NPI-1 (aka random()), se stredem u 0.5
  //  j = fint(random_weibull(10, 3.0));    // pro (10.0, 3.0) je out mezi 0...3 (aka random()), se stredem vys (pro 10)
  //  j = fint(random_gamma(1.0,0.5));    // pro (1.0, 0.5) je out mezi 0...5 (aka random()), se stredem niz (kolem 1.0)
    if(j &lt; 0) j=0;
    if(j &gt; (NPI-1)) j=NPI-1;
    bits[j] ^= 1;

   if(inCoverSet[input]) { inSame = -1*input; nsame++; }
   else inSame = input;
   inCoverSet[bin2dec()] = true;
    covered();

    rCover = 100.0*bitsCovered / NTV; 

    inCoverage = 0.0;
}

double EP() {
    //error probability
    //number of different outputs divided by 2^NPI
    double ret = dif_count / (1.0*PWR2_NPI);

    return ret;
}

double MAE() {
    //mean absolute error
    //sum of differences (approx. vs acc.) divided by 2^NPI
    double ret = out_sum_all_diff / (1.0*PWR2_NPI);

    return ret;
}

double MSE() {
    //mean squared error
    //sum of squared differences divided by 2^NPI
    double ret = out_sum_all_diff_squared / (1.0*PWR2_NPI);

    return ret;
}

double MRE() {
    //mean relative error
    //mean error in relation to size of accurate output
    double ret = out_sum_relative / (1.0*PWR2_NPI);

    return ret;
}

void calc_metrics() {
    error_prob = EP();
    mean_abs_error = MAE();
    mean_squared_error = MSE();
    mean_relative_error = MRE();
}

void inits(){
    int i;
    for(i:int[0,MAX_INNER_NODES-1]){ nodes[i].flag=false; }
    for(i:int[0,NPI-1]){
        if(exists(j:int[0,NPI-1]) PIxy[j]==i){ 
            nodes[i].flag=true;    
            nodes[i].dly=0;        
        }
        approxCircNodes++;
    }
    for(i=0; i&lt;approxCircGates; i++) gates[i].flag=false;
    while(exists(i:int[0,MAX_INNER_GATES-1]) (gates[i].flag==false &amp;&amp; i&lt;approxCircGates)){
        approxCircDepth++;
        for(i=0; i&lt;approxCircGates; i++) {
            if(!gates[i].flag &amp;&amp; nodes[gates[i].in0].flag &amp;&amp; nodes[gates[i].in1].flag){  
                nodes[gates[i].out0].dly = (nodes[gates[i].in0].dly&gt;nodes[gates[i].in1].dly?nodes[gates[i].in0].dly:nodes[gates[i].in1].dly) + duration(tbl_op[i]);
                nodes[gates[i].out0].flag=true;
                approxCircNodes++;
                if(nodes[gates[i].out0].dly&gt;approxCircDly){ approxCircDly=nodes[gates[i].out0].dly; }

                gates[i].flag=true; 
            }  
        }
    }
}</declaration>
		<location id="id14" x="-119" y="-102">
			<name x="-129" y="-136">wait</name>
		</location>
		<location id="id15" x="-246" y="0">
			<name x="-255" y="8">get</name>
			<committed/>
		</location>
		<location id="id16" x="170" y="0">
			<name x="153" y="8">done</name>
			<label kind="invariant" x="136" y="-34">tcover'==0</label>
		</location>
		<location id="id17" x="0" y="0">
			<name x="-17" y="8">apply</name>
			<committed/>
		</location>
		<location id="id18" x="-246" y="-102">
			<committed/>
		</location>
		<location id="id19" x="-374" y="0">
			<urgent/>
		</location>
		<init ref="id19"/>
		<transition>
			<source ref="id19"/>
			<target ref="id15"/>
			<label kind="assignment" x="-331" y="0">inits()</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id15"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-212" y="-102">cmpDone?</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id14"/>
			<label kind="guard" x="-93" y="-93">!inCovered()</label>
			<nail x="0" y="-102"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-153" y="-25">update!</label>
			<label kind="assignment" x="-144" y="0">f(idx)</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="guard" x="42" y="-25">inCovered()</label>
			<label kind="assignment" x="34" y="0">allCovered=true, calc_metrics()</label>
		</transition>
	</template>
	<template>
		<name>tmul2_tb_random</name>
		<parameter>const int dly, const double covratio</parameter>
		<declaration>clock x;
clock tcover;
int input=0;
int[0, MAX_INT] nsame=0;
int[0, MAX_INT] inSame=0;
double rCover;
int idx=0;

bool inCoverSet[NTV];

int[0, MAX_INT] covered()
{
    int[0, MAX_INT] cnt=0;

    for(i: int[0,NTV-1])
    {
        if(inCoverSet[i]) {
            cnt++;
        }
    }

    bitsCovered=cnt;

    return cnt;
}

int[0, MAX_INT] bin2dec()
{
    int[0, MAX_INT] result=0;
	int i;
    for(i=0; i&lt;NPI; i++){
        result += bits[i]*TBL_PWR2[i];
    }

    return result;
}


bool inCovered()
{
  return forall (i : int[0,NTV-1]) inCoverSet[i];    
}

int[0, MAX_INT] combine_inputs(bool &amp;in1_binary[NPI/2], bool &amp;in2_binary[NPI/2]) {
    //Concatenate both binary representations of inputs and then convert that to dec
    bool both_binary[NPI];
    int[0, MAX_INT] ret = 0;

    //concatenate both inputs
    for(i:int[0,(NPI/2) - 1]) {
        both_binary[i] = in1_binary[i];
        both_binary[i+NPI/2] = in2_binary[i];
    }
    
    //convert that result to decimal number
    for(i:int[0,NPI-1]) {
        ret += both_binary[i] * TBL_PWR2[i];
    }

    return ret;
}

void unique_input_insert(int[0, MAX_INT] input) {
    for(i:int[0,MAX_INT-1]) {
        if(unique_inputs[i] == -1) {
            unique_inputs[i] = input;
            return;
        }
    }
}

bool input_covered(int[0, MAX_INT] input) {
    //if the input is already in the unique_inputs array return True
    //else return False
    return exists (i : int[0,MAX_INT-1]) input == unique_inputs[i];
}

void dec_to_bin(int[0,MAX_INT] number, bool &amp;number_binary[NPI/2]) {
    //init all bits to 0
    int j = 0;
    for(i:int[0,(NPI/2 - 1)]) {
        number_binary[i] = 0;
    }

    if(number == 0) { 
        return; 
    }

    while(number &gt; 0) {
        number_binary[j] = number % 2;
        number /= 2;
        j++;
    }
}

int[0, MAX_INT] check_limits(int[-MAX_INT, MAX_INT] number, int[0, MAX_INT] min, int[0, MAX_INT] max) {
    if(number &lt; min) number = min;
    if(number &gt; max) number = max;
    return number;
}

void f(int i){
    bool a_binary[NPI/2];
    bool b_binary[NPI/2];

    int[0, MAX_INT] imax = fint(exp2(NPI/2));

    input_a = 0;
    input_b = 0;

    current_delay = 0.0; //reset delay counter
    if(res_count &gt; 0) { delay_avg = delay_sum / res_count; }

    //Distribution

    input_a = check_limits(input_a, 0, imax);
    input_b = check_limits(input_b, 0, imax);

    dec_to_bin(input_a, a_binary);
    dec_to_bin(input_b, b_binary);

    for(i:int[0,NPI/2 - 1]) {
        bits[i] = a_binary[i];
        bits[i+NPI/2] = b_binary[i];
    }

    //check if this bit combination has already been used
    comb_input = combine_inputs(a_binary, b_binary);
    if(not input_covered(comb_input)) {
        unique_input_insert(comb_input);
        unique_count++;

        coverage_percentage = (1.0*unique_count / MAX_INT) * 100;
    }

    if(inCoverSet[input]) { inSame = -1*input; nsame++; }
    else inSame = input;
    inCoverSet[bin2dec()] = true;
    covered();

    rCover = 100.0*bitsCovered / NTV; 

    inCoverage = 0.0;
}

void inits(){
    int i;

    //set all elements of unique_inputs array to -1
    //eventually they shall all be replaced by different input combos
    for(i:int[0,MAX_INT-1]) { unique_inputs[i] = -1; }

    for(i:int[0,MAX_INNER_NODES-1]){ nodes[i].flag=false; }
    for(i:int[0,NPI-1]){
        if(exists(j:int[0,NPI-1]) PIxy[j]==i){ 
            nodes[i].flag=true;    
            nodes[i].dly=0;        
        }
        approxCircNodes++;
    }
    for(i=0; i&lt;approxCircGates; i++) gates[i].flag=false;
    while(exists(i:int[0,MAX_INNER_GATES-1]) (gates[i].flag==false &amp;&amp; i&lt;approxCircGates)){
        approxCircDepth++;
        for(i=0; i&lt;approxCircGates; i++) {
            if(!gates[i].flag &amp;&amp; nodes[gates[i].in0].flag &amp;&amp; nodes[gates[i].in1].flag){  
                nodes[gates[i].out0].dly = (nodes[gates[i].in0].dly&gt;nodes[gates[i].in1].dly?nodes[gates[i].in0].dly:nodes[gates[i].in1].dly) + duration(tbl_op[i]);
                nodes[gates[i].out0].flag=true;
                approxCircNodes++;
                if(nodes[gates[i].out0].dly&gt;approxCircDly){ approxCircDly=nodes[gates[i].out0].dly; }

                gates[i].flag=true; 
            }  
        }
    }
}</declaration>
		<location id="id14" x="-119" y="-102">
			<name x="-129" y="-136">wait</name>
		</location>
		<location id="id15" x="-246" y="0">
			<name x="-255" y="8">get</name>
			<committed/>
		</location>
		<location id="id16" x="170" y="0">
			<name x="153" y="8">done</name>
			<label kind="invariant" x="136" y="-34">tcover'==0</label>
		</location>
		<location id="id17" x="0" y="0">
			<name x="-17" y="8">apply</name>
			<committed/>
		</location>
		<location id="id18" x="-246" y="-102">
			<committed/>
		</location>
		<location id="id19" x="-374" y="0">
			<urgent/>
		</location>
		<init ref="id19"/>
		<transition>
			<source ref="id19"/>
			<target ref="id15"/>
			<label kind="assignment" x="-331" y="0">inits()</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id15"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-212" y="-102">cmpDone?</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id14"/>
			<label kind="guard" x="-93" y="-93">!inCovered()</label>
			<nail x="0" y="-102"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-153" y="-25">update!</label>
			<label kind="assignment" x="-144" y="0">f(idx)</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="guard" x="42" y="-25">inCovered()</label>
			<label kind="assignment" x="34" y="0">allCovered=true</label>
		</transition>
	</template>
	<template>
		<name>tmul2_tb_random</name>
		<parameter>const int dly, const double covratio</parameter>
		<declaration>clock x;
clock tcover;
int input=0;
int[0, MAX_INT] nsame=0;
int[0, MAX_INT] inSame=0;
double rCover;
int idx=0;

bool inCoverSet[NTV];

int[0, MAX_INT] covered()
{
    int[0, MAX_INT] cnt=0;

    for(i: int[0,NTV-1])
    {
        if(inCoverSet[i]) {
            cnt++;
        }
    }

    bitsCovered=cnt;

    return cnt;
}

int[0, MAX_INT] bin2dec()
{
    int[0, MAX_INT] result=0;
	int i;
    for(i=0; i&lt;NPI; i++){
        result += bits[i]*TBL_PWR2[i];
    }

    return result;
}


bool inCovered()
{
  return forall (i : int[0,NTV-1]) inCoverSet[i];    
}

/*
void f(int i){
    int j, k;
    int min = 0;
    int max = (NPI/2) - 1;

    //flipping bits in the first number (bits &lt;0,NPI/2-1&gt;)
    //eg. &lt;0,7&gt; for an 8x8bit mult.

    //generate which bit should change
    j=fint(random(NPI/2));

    //overflow and underflow corrections
    if(j &lt; min) j=min;
    if(j &gt; max) j=max;

    bits[j] ^= 1; //flip the selected bit, so 0 -&gt; 1, 1 -&gt; 0

    //flipping bits in the second number (bits &lt;NPI/2,NPI-1&gt;)
    //eg. &lt;8,15&gt; for an 8x8bit mult.
    
    //generate which bit should change
    k = fint(random(NPI/2));

    //overflow and underflow corrections
    if(k &lt; min) k=min;
    if(k &gt; max) k=max;
    k += NPI/2; //shift to the correct bit range

    bits[k] ^= 1; //flip the selected bit, so 0 -&gt; 1, 1 -&gt; 0

    //check if this bit combination has already been used
    if(inCoverSet[input]) { inSame = -1*input; nsame++; }
    else inSame = input;
    inCoverSet[bin2dec()] = true;
    covered();

    rCover = 100.0*bitsCovered / NTV; 

    inCoverage = 0.0;
}
*/

void dec_to_bin(int number, bool &amp;number_binary[NPI/2]) {
    //init all bits to 0
    int j = 0;
    int index;
    for(i:int[0,(NPI/2 - 1)]) {
        number_binary[i] = 0;
    }

    if(number == 0) { 
        return; 
    }

    while(number &gt; 0) {
        index = NPI/2 - 1 - j;
        if(index &lt; 0) index = 0;
        number_binary[index] = number % 2;
        number /= 2;
        j++;
    }
}

int check_limits(int number, int min, int max) {
    if(number &lt; min) number = min;
    if(number &gt; max) number = max;
    return number;
}

void f(int i){
    int j, k;
    bool j_binary[NPI/2];
    bool k_binary[NPI/2];

    int imax = fint(exp2(NPI));

    j = fint(random_tri(0,0,imax));
    k = fint(random(imax));

    j = check_limits(j, 0, imax);
    k = check_limits(k, 0, imax);

    dec_to_bin(j, j_binary);
    dec_to_bin(k, k_binary);

    for(i:int[0,NPI/2 - 1]) {
        bits[i] = j_binary[i];
        bits[i+NPI/2] = k_binary[i];
    }

    //check if this bit combination has already been used
    if(inCoverSet[input]) { inSame = -1*input; nsame++; }
    else inSame = input;
    inCoverSet[bin2dec()] = true;
    covered();

    rCover = 100.0*bitsCovered / NTV; 

    inCoverage = 0.0;
}

void inits(){
    int i;
    for(i:int[0,MAX_INNER_NODES-1]){ nodes[i].flag=false; }
    for(i:int[0,NPI-1]){
        if(exists(j:int[0,NPI-1]) PIxy[j]==i){ 
            nodes[i].flag=true;    
            nodes[i].dly=0;        
        }
        approxCircNodes++;
    }
    for(i=0; i&lt;approxCircGates; i++) gates[i].flag=false;
    while(exists(i:int[0,MAX_INNER_GATES-1]) (gates[i].flag==false &amp;&amp; i&lt;approxCircGates)){
        approxCircDepth++;
        for(i=0; i&lt;approxCircGates; i++) {
            if(!gates[i].flag &amp;&amp; nodes[gates[i].in0].flag &amp;&amp; nodes[gates[i].in1].flag){  
                nodes[gates[i].out0].dly = (nodes[gates[i].in0].dly&gt;nodes[gates[i].in1].dly?nodes[gates[i].in0].dly:nodes[gates[i].in1].dly) + duration(tbl_op[i]);
                nodes[gates[i].out0].flag=true;
                approxCircNodes++;
                if(nodes[gates[i].out0].dly&gt;approxCircDly){ approxCircDly=nodes[gates[i].out0].dly; }

                gates[i].flag=true; 
            }  
        }
    }
}</declaration>
		<location id="id14" x="-119" y="-102">
			<name x="-129" y="-136">wait</name>
		</location>
		<location id="id15" x="-246" y="0">
			<name x="-255" y="8">get</name>
			<committed/>
		</location>
		<location id="id16" x="170" y="0">
			<name x="153" y="8">done</name>
			<label kind="invariant" x="136" y="-34">tcover'==0</label>
		</location>
		<location id="id17" x="0" y="0">
			<name x="-17" y="8">apply</name>
			<committed/>
		</location>
		<location id="id18" x="-246" y="-102">
			<committed/>
		</location>
		<location id="id19" x="-374" y="0">
			<urgent/>
		</location>
		<init ref="id19"/>
		<transition>
			<source ref="id19"/>
			<target ref="id15"/>
			<label kind="assignment" x="-331" y="0">inits()</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id15"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-212" y="-102">cmpDone?</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id14"/>
			<label kind="guard" x="-93" y="-93">!inCovered()</label>
			<nail x="0" y="-102"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-153" y="-25">update!</label>
			<label kind="assignment" x="-144" y="0">f(idx)</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="guard" x="42" y="-25">inCovered()</label>
			<label kind="assignment" x="34" y="0">allCovered=true</label>
		</transition>
	</template>
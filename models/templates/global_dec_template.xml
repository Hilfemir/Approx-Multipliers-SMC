<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
<declaration>/* Feel free to cite and/or read details to the model using:
  STRNADEL Josef. Statistical Model Checking of Approximate Circuits: Challenges and Opportunities. In: Proceedings of the 2020 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE). Grenoble: IEEE Computer Society, 2020, pp. 1574-1577. ISBN 978-3-9819263-4-7. Available from: https://ieeexplore.ieee.org/document/9116207 and https://www.fit.vut.cz/research/publication/12055/
 */
const int MAX_INT = 65536;

double dif_count = 0;
double res_count = 0;
int[0, MAX_INT] unique_count = 0;

int[0, MAX_INT] comb_input;
int[-1,MAX_INT] unique_inputs[MAX_INT];
double coverage_percentage = 0.0;

double out_sum_all_acc;
double out_sum_all_approx;
double out_sum_all_diff;
double out_sum_all_diff_squared;

double out_sum_relative;

int hamming_distance = 0;
int max_hamming_distance = 0;
double error_prob = 0.0;
double mean_abs_error = 0.0;
double mean_squared_error = 0.0;
double mean_relative_error = 0.0;
double worst_case_error = 0.0;
double worst_case_relative_error = 0.0;
double worst_delay = 0.0;
double current_delay = 0.0;
double delay_sum = 0.0;
double delay_avg = 0.0;

double rnd;

broadcast chan change[1000];
int outcnt=0;

double bit_flips = 0.0;
double avg_flips_per_res = 0.0;
double bit_flips_sum = 0.0;
double max_bit_flips = 0.0;

const int NOPS = 9;
typedef int[0,NOPS-1] tOp;

int input_a;
int input_b;

const tOp OP_NOT = 0;
const tOp OP_DLY = 1;
const tOp OP_AND = 2;
const tOp OP_NAND = 3;
const tOp OP_OR = 4;
const tOp OP_NOR = 5;
const tOp OP_XOR = 6;
const tOp OP_XNOR = 7;
const tOp OP_SET = 8;

const int NCOM = 7;
tOp tbl_op[NCOM] = {2, 2, 4, 2, 2, 0, 1};         

int duration(tOp op){  
    int duration=0;
    if(op==OP_NOT) duration=3;
    if(op==OP_DLY) duration=10;
    if(op==OP_AND) duration=10;
    if(op==OP_NAND) duration=13;
    if(op==OP_OR) duration=10;
    if(op==OP_NOR) duration=13;
    if(op==OP_XOR) duration=20;
    if(op==OP_XNOR) duration=23;
    if(op==OP_SET) duration=0;
    return duration;
}

broadcast chan go, pwrUp;

const double COVERAGE_RATIO = 100.0;
const int DLY_ZERO = 0;

const int TBL_PWR2[31] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824};

broadcast chan update;
broadcast chan cmpDone;

const int MAX_BITS = 1024;
bool bits[MAX_BITS];
bool difference=false;
bool dif2=false;
int diffctrl=0;
int[-MAX_INT, MAX_INT] err_magn_v;    
double err_magn_r;

int[0, MAX_INT] bitsCovered;
double inCoverage;

bool allCovered=false;

const int NIB_MUL2 = 4;              
const int NOB_MUL2 = 4;        
const int NTV_MUL2 = TBL_PWR2[NIB_MUL2]; 
const int DLY_MUL2 = 500;                 

/* ===------------------------  ------------------------==== */
int getMasked(int w, int offset, int[0,MAX_INT] data){ 
    int mask = (TBL_PWR2[w]-1);    
   return (data &amp; (mask &lt;&lt; offset)) &gt;&gt; offset;     
}    
bool getBit(int pos, int[0,MAX_INT] data){ return getMasked(1, pos, data); }

const int NIB_ANY = 4;                  
const int NOB_ANY = 4;                  
const int NTV_ANY = TBL_PWR2[NIB_ANY]; 
const int DLY_ANY = 20;                 
bool tbl_acc_any[TBL_PWR2[NIB_ANY]][NIB_ANY+NOB_ANY];
//
const int NFUN = 1;
typedef int[0,NFUN-1] tFun;
//-------
const tFun F_MUL = 0;
//
void fill_tbl_acc_any(int win, int wout, tFun f, int fdly){ 
    int[0,MAX_INT] i;
    int[0,MAX_INT] result;
    int j, k, op0, op1;
    for(i=0; i&lt;TBL_PWR2[win]; i++){    
        for(j=0; j&lt;win; j++){
            tbl_acc_any[i][j] = getBit(j,i);
        }
        if(f==F_MUL){
            op0 = getMasked(win/2, 0, i);
            op1 = getMasked(win/2, win/2, i);
            result = op0*op1;
        }
        else { result = 0; }
        for(k=0; k&lt;wout; k++){
            tbl_acc_any[i][win+(wout-k-1)] = getBit(k,result);
        }
    }
}

/* ===------------------------  ------------------------==== */
const int NPI = NIB_MUL2;    
const int NPO = NOB_MUL2;   
//
const int NTV = NTV_MUL2; 
const int DLY = DLY_MUL2;
//
const int PIxy[NPI] = {0,1,2,3};
const int POx[NPO] = {4,5,6,7};     
//
const int POy[NPO] = {8,9,10,-1};

int[0, 1073741824] PWR2_NPI = TBL_PWR2[NPI];
/* ===------------------------  ------------------------==== */

const int MAX_INNER_NODES = 1000;
typedef struct {
    int dly;
    bool flag;
} sNode;
sNode nodes[MAX_INNER_NODES];

const int MAX_INNER_GATES = 1000;
typedef struct {
    bool active;
    int in0;
    int in1;
    int inAvail;
    int out0;
    int dly;
    int depth;
    bool flag;
} sGate;
sGate gates[MAX_INNER_GATES];

int[0, 1073741824] approxCircNodes = 0;
int[0, 1073741824] approxCircGates = 0;
int approxCircDly=0;
int[0, 1073741824] approxCircDepth=0;


bool outEq(){
    bool same=true;
    int i;
    hamming_distance = 0;
    for(i=0; i&lt;NPO; i++){
        if((POx[i]&gt;=0) &amp;&amp; (POy[i]&gt;=0)){
            if(bits[POx[i]] != bits[POy[i]]){
                hamming_distance++;
                same = false;
            }
        }
    }
    
    if (same == false) {
        dif_count = dif_count + 1;
    }

    if (hamming_distance &gt; max_hamming_distance) {
        max_hamming_distance = hamming_distance;
    }

    res_count = res_count + 1;

    return same;
}

double EP() {
    //error probability
    //number of different outputs divided by number of results
    double ret = dif_count / res_count;

    return ret;
}

double MAE() {
    //mean absolute error
    //sum of differences (approx. vs acc.) divided by number of results
    double ret = out_sum_all_diff / res_count;

    return ret;
}

double MSE() {
    //mean squared error
    //sum of squared differences divided by number of results
    double ret = out_sum_all_diff_squared / res_count;

    return ret;
}

double MRE() {
    //mean relative error
    //mean error in relation to size of accurate output
    double ret = out_sum_relative / res_count;

    return ret;
}

double avg_bitflips() {
    //total number of bit flips divided by number of results
    double ret = bit_flips_sum / res_count;

    return ret;
}

void calc_metrics() {
    error_prob = EP();
    mean_abs_error = MAE();
    mean_squared_error = MSE();
    mean_relative_error = MRE();
    avg_flips_per_res = avg_bitflips();
}

int[0, MAX_INT] res_acc=0;
int[0, MAX_INT] res_approx=0;

void diff(){
    int i;
    double res_dif;
    double relative_res_dif;
    res_acc = 0;
    res_approx = 0;

    difference = !outEq();

     for(i=0; i&lt;=NPO-1; i++){                                       
        res_acc += bits[i+NPI]*TBL_PWR2[i];
        if(POy[i]&gt;=0) res_approx += bits[i+NPI+NPO]*TBL_PWR2[i];    
    }
    out_sum_all_acc = out_sum_all_acc + res_acc;
    out_sum_all_approx = out_sum_all_approx + res_approx;

    out_sum_all_diff = fabs(out_sum_all_acc - out_sum_all_approx);
    out_sum_all_diff_squared = out_sum_all_diff_squared + pow(abs(res_approx-res_acc),2);
    out_sum_relative = out_sum_relative + (abs(res_approx-res_acc) / fmax(1.0, 1.0*res_acc));

    res_dif = 1.0 * abs(res_approx - res_acc);
    if (res_dif &gt; worst_case_error) {
        worst_case_error = res_dif;
    }

    relative_res_dif = abs(res_approx - res_acc) / fmax(1.0, 1.0*res_acc);
    if (relative_res_dif &gt; worst_case_relative_error) {
        worst_case_relative_error = relative_res_dif;
    }

    err_magn_v = res_acc - res_approx;
    if(res_acc!=0) err_magn_r = 1-((1.0*res_approx)/(1.0*res_acc));

    if(max_bit_flips &lt; bit_flips) {
        max_bit_flips = bit_flips;
    }

    bit_flips = 0;

    calc_metrics();
}
</declaration>
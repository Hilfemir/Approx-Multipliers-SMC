<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>/* Feel free to cite and/or read details to the model using:
  STRNADEL Josef. Statistical Model Checking of Approximate Circuits: Challenges and Opportunities. In: Proceedings of the 2020 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE). Grenoble: IEEE Computer Society, 2020, pp. 1574-1577. ISBN 978-3-9819263-4-7. Available from: https://ieeexplore.ieee.org/document/9116207 and https://www.fit.vut.cz/research/publication/12055/
 */
double rnd;

broadcast chan change[1000];
int outcnt=0;

const int NOPS = 9;
typedef int[0,NOPS-1] tOp;

const int MAX_INT = 65536;

const tOp OP_NOT = 0;
const tOp OP_DLY = 1;
const tOp OP_AND = 2;
const tOp OP_NAND = 3;
const tOp OP_OR = 4;
const tOp OP_NOR = 5;
const tOp OP_XOR = 6;
const tOp OP_XNOR = 7;
const tOp OP_SET = 8;

const int NCOM = 241;
tOp tbl_op[NCOM] = {2, 2, 2, 2, 2, 2, 4, 2, 6, 2, 6, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 6, 4, 2, 2, 2, 2, 2, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 2, 2, 2, 2, 2, 2, 4, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 2, 2, 2, 2, 2, 2, 2, 2, 0, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 2, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 8, 8, 1};

int duration(tOp op){  
    int duration=0;
    if(op==OP_NOT) duration=3;
    if(op==OP_DLY) duration=10;
    if(op==OP_AND) duration=10;
    if(op==OP_NAND) duration=13;
    if(op==OP_OR) duration=10;
    if(op==OP_NOR) duration=13;
    if(op==OP_XOR) duration=20;
    if(op==OP_XNOR) duration=23;
    if(op==OP_SET) duration=1;
    return duration;
}

broadcast chan go, pwrUp;

const double COVERAGE_RATIO = 100.0;
const int DLY_ZERO = 0;

const int TBL_PWR2[31] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824};

broadcast chan update;
broadcast chan cmpDone;

const int MAX_BITS = 1024;
bool bits[MAX_BITS];
bool difference=false;
bool dif2=false;
int diffctrl=0;
int err_magn_v;    
double err_magn_r;  

int[-MAX_INT*2,MAX_INT*2] out_sum_all_acc;
int[-MAX_INT*2,MAX_INT*2] out_sum_all_approx;
int[-MAX_INT*2,MAX_INT*2] out_sum_all_diff;

int bitsCovered;
double inCoverage;

bool allCovered=false;

const int NIB_MUL2 = 16;
const int NOB_MUL2 = 16;
const int NTV_MUL2 = TBL_PWR2[NIB_MUL2]; 
const int DLY_MUL2 = 20;                 

/* ===------------------------  ------------------------==== */
int getMasked(int w, int offset, int[0,MAX_INT] data){ 
    int mask = (TBL_PWR2[w]-1);    
   return (data &amp; (mask &lt;&lt; offset)) &gt;&gt; offset;     
}    
bool getBit(int pos, int[0,MAX_INT] data){ return getMasked(1, pos, data); }

const int NIB_ANY = 16;
const int NOB_ANY = 16;
const int NTV_ANY = TBL_PWR2[NIB_ANY]; 
const int DLY_ANY = 20;                 
bool tbl_acc_any[TBL_PWR2[NIB_ANY]][NIB_ANY+NOB_ANY];
//
const int NFUN = 1;
typedef int[0,NFUN-1] tFun;
//-------
const tFun F_MUL = 0;
//
void fill_tbl_acc_any(int win, int wout, tFun f, int fdly){ 
    int[0,MAX_INT] i;
    int[0,MAX_INT] result;
    int j, k, op0, op1;
    for(i=0; i&lt;TBL_PWR2[win]; i++){    
        for(j=0; j&lt;win; j++){
            tbl_acc_any[i][j] = getBit(j,i);
        }
        if(f==F_MUL){
            op0 = getMasked(win/2, 0, i);
            op1 = getMasked(win/2, win/2, i);
            result = op0*op1;
        }
        else { result = 0; }
        for(k=0; k&lt;wout; k++){
            tbl_acc_any[i][win+(wout-k-1)] = getBit(k,result);
        }
    }
}

/* ===------------------------  ------------------------==== */
const int NPI = NIB_MUL2;    
const int NPO = NOB_MUL2;   
//
const int NTV = NTV_MUL2; 
const int DLY = DLY_MUL2;
//
const int PIxy[NPI] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
const int POx[NPO] = {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31};
//
const int POy[NPO] = {32, 33, 34, 35, 36, -1, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47};
/* ===------------------------  ------------------------==== */

const int MAX_INNER_NODES = 1000;
typedef struct {
    int dly;
    bool flag;
} sNode;
sNode nodes[MAX_INNER_NODES];

const int MAX_INNER_GATES = 1000;
typedef struct {
    bool active;
    int in0;
    int in1;
    int inAvail;
    int out0;
    int dly;
    int depth;
    bool flag;
} sGate;
sGate gates[MAX_INNER_GATES];

int approxCircNodes = 0;
int approxCircGates = 0;
int approxCircDly=0;
int approxCircDepth=0;


bool outEq(){
    bool same=true;
    int i;
    for(i=0; i&lt;NPO; i++){
        if((POx[i]&gt;=0) &amp;&amp; (POy[i]&gt;=0)){
            if(bits[POx[i]] != bits[POy[i]]){
                same = false;
            }
        }
    }
    return same;
}

void diff(){
    int res_acc=0, res_approx=0;
    int i;

    difference = !outEq();

     for(i=0; i&lt;=NPO-1; i++){                                       
        res_acc += bits[i+NPI]*TBL_PWR2[i];
        if(POy[i]&gt;=0) res_approx += bits[i+NPI+NPO]*TBL_PWR2[i];    
    }
    out_sum_all_acc += res_acc;
    out_sum_all_approx += res_approx;
    out_sum_all_diff = out_sum_all_acc - out_sum_all_approx;
    err_magn_v = res_acc - res_approx;
    if(res_acc!=0) err_magn_r = 1-((1.0*res_approx)/(1.0*res_acc));
}
</declaration>
	<template>
		<name>tmul2any</name>
		<parameter>const int &amp;PIxy[NPI], const int &amp;POx[NPO], bool &amp;ttbl[TBL_PWR2[NIB_ANY]][NIB_ANY+NOB_ANY], const int  dly</parameter>
		<declaration>
clock x;

int getIdx(int i){
    int idx=-1;

    if(i &lt; NPI) {
        idx = PIxy[i];
    }
    else {
        idx = POx[i-NPI];
    }

    return idx;
}


int bin2dec()
{
    int result=0, i;
    for(i=0; i&lt;NIB_MUL2; i++){
        result += bits[getIdx(i)]*TBL_PWR2[i];
    }

    return result;
}


int getOut(){
    int res, i;
    for(i=NIB_MUL2; i&lt;NIB_MUL2+NOB_MUL2; i++){
        res += bits[getIdx(i)]*TBL_PWR2[i-NIB_MUL2];
    }
    return res;    
}

void f(){
    if(POx[15]&gt;=0) bits[POx[15]]=ttbl[bin2dec()][16];
    if(POx[14]&gt;=0) bits[POx[14]]=ttbl[bin2dec()][17];
    if(POx[13]&gt;=0) bits[POx[13]]=ttbl[bin2dec()][18];
    if(POx[12]&gt;=0) bits[POx[12]]=ttbl[bin2dec()][19];
    if(POx[11]&gt;=0) bits[POx[11]]=ttbl[bin2dec()][20];
    if(POx[10]&gt;=0) bits[POx[10]]=ttbl[bin2dec()][21];
    if(POx[9]&gt;=0) bits[POx[9]]=ttbl[bin2dec()][22];
    if(POx[8]&gt;=0) bits[POx[8]]=ttbl[bin2dec()][23];
    if(POx[7]&gt;=0) bits[POx[7]]=ttbl[bin2dec()][24];
    if(POx[6]&gt;=0) bits[POx[6]]=ttbl[bin2dec()][25];
    if(POx[5]&gt;=0) bits[POx[5]]=ttbl[bin2dec()][26];
    if(POx[4]&gt;=0) bits[POx[4]]=ttbl[bin2dec()][27];
    if(POx[3]&gt;=0) bits[POx[3]]=ttbl[bin2dec()][28];
    if(POx[2]&gt;=0) bits[POx[2]]=ttbl[bin2dec()][29];
    if(POx[1]&gt;=0) bits[POx[1]]=ttbl[bin2dec()][30];
    if(POx[0]&gt;=0) bits[POx[0]]=ttbl[bin2dec()][31];

    diffctrl++;
}

void inits(){
    fill_tbl_acc_any(NIB_ANY, NOB_ANY, F_MUL, dly);
}

</declaration>
		<location id="id0" x="-170" y="0">
		</location>
		<location id="id1" x="0" y="0">
			<label kind="invariant" x="-25" y="17">x&lt;=dly</label>
		</location>
		<location id="id2" x="-374" y="0">
			<committed/>
		</location>
		<init ref="id2"/>
		<transition id="id3">
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="assignment" x="-297" y="0">inits()</label>
		</transition>
		<transition id="id4">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="guard" x="-152" y="-136">x==dly</label>
			<label kind="assignment" x="17" y="-59">f()</label>
			<nail x="0" y="-102"/>
			<nail x="-170" y="-102"/>
		</transition>
		<transition id="id5">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-110" y="-25">update?</label>
			<label kind="assignment" x="-93" y="0">x=0</label>
		</transition>
	</template>
	<template>
		<name>tmul2_tb_exhaust</name>
		<parameter>const int &amp;PIxy[NPI], const int dly, const double covratio</parameter>
		<declaration>
clock x;
clock tcover;
int input=0;
int nsame=0, inSame=0;
double rCover;

bool inCoverSet[NTV];

int covered()
{
    int cnt=0;

    for(i: int[0,NTV-1])
    {
        if(inCoverSet[i]) {
            cnt++;
        }
    }

    bitsCovered=cnt;

    return cnt;
}

int bin2dec()
{
    int result=0, i;
    for(i=0; i&lt;NPI; i++){
        result += bits[i]*TBL_PWR2[i];
    }

    return result;
}


bool inCovered()
{
  return forall (i : int[0,NTV-1]) inCoverSet[i];    
}



void f(){
    bits[PIxy[0]] = getBit(0, input);
    bits[PIxy[1]] = getBit(1, input);
    bits[PIxy[2]] = getBit(2, input);
    bits[PIxy[3]] = getBit(3, input);
    bits[PIxy[4]] = getBit(4, input);
    bits[PIxy[5]] = getBit(5, input);
    bits[PIxy[6]] = getBit(6, input);
    bits[PIxy[7]] = getBit(7, input);

    if(inCoverSet[input]) { inSame = -1*input; nsame++; }
    else inSame = input;
    inCoverSet[input] = true;
    input = (input+1) % NTV;
    covered();

    rCover = 100.0*bitsCovered / NTV; 
}

void inits(){
    int i;
    for(i:int[0,MAX_INNER_NODES-1]){ nodes[i].flag=false; }
    for(i:int[0,NPI-1]){
        if(exists(j:int[0,NPI-1]) PIxy[j]==i){ 
            nodes[i].flag=true;    
            nodes[i].dly=0;        
        }
        approxCircNodes++;
    }
    for(i=0; i&lt;approxCircGates; i++) gates[i].flag=false;    
    while(exists(i:int[0,MAX_INNER_GATES-1]) (gates[i].flag==false &amp;&amp; i&lt;approxCircGates)){
        approxCircDepth++;
        for(i=0; i&lt;approxCircGates; i++) {
            if(!gates[i].flag &amp;&amp; nodes[gates[i].in0].flag &amp;&amp; nodes[gates[i].in1].flag){  
                nodes[gates[i].out0].dly = (nodes[gates[i].in0].dly&gt;nodes[gates[i].in1].dly?nodes[gates[i].in0].dly:nodes[gates[i].in1].dly) + duration(tbl_op[i]);
                nodes[gates[i].out0].flag=true;
                approxCircNodes++;
                if(nodes[gates[i].out0].dly&lt;approxCircDly){ approxCircDly=nodes[gates[i].out0].dly; }

                gates[i].flag=true;   
            }  
        }
    }
}
</declaration>
		<location id="id6" x="-136" y="0">
			<name x="-153" y="8">apply</name>
			<committed/>
		</location>
		<location id="id7" x="-374" y="0">
			<name x="-382" y="8">get</name>
			<committed/>
		</location>
		<location id="id8" x="34" y="0">
			<name x="17" y="8">done</name>
			<label kind="invariant" x="0" y="-34">tcover'==0</label>
		</location>
		<location id="id9" x="-246" y="-102">
			<name x="-255" y="-136">wait</name>
		</location>
		<location id="id10" x="-510" y="0">
			<urgent/>
		</location>
		<init ref="id10"/>
		<transition id="id11">
			<source ref="id10"/>
			<target ref="id7"/>
			<label kind="assignment" x="-459" y="0">inits()</label>
		</transition>
		<transition id="id12">
			<source ref="id6"/>
			<target ref="id9"/>
			<label kind="guard" x="-221" y="-93">!inCovered()</label>
			<nail x="-136" y="-102"/>
		</transition>
		<transition id="id13">
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="guard" x="-93" y="-25">inCovered()</label>
			<label kind="assignment" x="-110" y="0">allCovered=true,
x=0</label>
		</transition>
		<transition id="id14">
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-289" y="-25">update!</label>
			<label kind="assignment" x="-280" y="0">f(), x=0</label>
		</transition>
		<transition id="id15">
			<source ref="id9"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-365" y="-93">cmpDone?</label>
			<nail x="-374" y="-102"/>
		</transition>
	</template>
	<template>
		<name>tmul2_tb_nondet</name>
		<parameter>const int range_min, const int range_max, const int dly, const double covratio</parameter>
		<declaration>clock x;
clock tcover;
int input=0;
int nsame=0, inSame=0;
double rCover;
int idx=0;

bool inCoverSet[NTV];

int covered()
{
    int cnt=0;

    for(i: int[0,NTV-1])
    {
        if(inCoverSet[i]) {
            cnt++;
        }
    }

    bitsCovered=cnt;

    return cnt;
}

int bin2dec()
{
    int result=0, i;
    for(i=0; i&lt;NPI; i++){
        result += bits[i]*TBL_PWR2[i];
    }

    return result;
}


bool inCovered()
{
  return forall (i : int[0,NTV-1]) inCoverSet[i];    
}

void f(int i){
    input = bin2dec();
   if(inCoverSet[input]) { inSame = -1*input; nsame++; }
  else inSame = input;
   inCoverSet[bin2dec()] = true;
    covered();

    rCover = 100.0*bitsCovered / NTV; 

    inCoverage = 0.0;
}

void inits(){
    int i;
    for(i:int[0,MAX_INNER_NODES-1]){ nodes[i].flag=false; }
    for(i:int[0,NPI-1]){
        if(exists(j:int[0,NPI-1]) PIxy[j]==i){ 
            nodes[i].flag=true;
            nodes[i].dly=0;      
        }
        approxCircNodes++;
    }
    for(i=0; i&lt;approxCircGates; i++) gates[i].flag=false;    
    while(exists(i:int[0,MAX_INNER_GATES-1]) (gates[i].flag==false &amp;&amp; i&lt;approxCircGates)){
        approxCircDepth++;
        for(i=0; i&lt;approxCircGates; i++) {
            if(!gates[i].flag &amp;&amp; nodes[gates[i].in0].flag &amp;&amp; nodes[gates[i].in1].flag){  
                nodes[gates[i].out0].dly = (nodes[gates[i].in0].dly&gt;nodes[gates[i].in1].dly?nodes[gates[i].in0].dly:nodes[gates[i].in1].dly) + duration(tbl_op[i]);
                nodes[gates[i].out0].flag=true;
                approxCircNodes++;
                if(nodes[gates[i].out0].dly&gt;approxCircDly){ approxCircDly=nodes[gates[i].out0].dly; }

                gates[i].flag=true;
            }  
        }
    }
}</declaration>
		<location id="id16" x="-119" y="-102">
			<name x="-129" y="-136">wait</name>
		</location>
		<location id="id17" x="-246" y="0">
			<name x="-255" y="8">get</name>
			<committed/>
		</location>
		<location id="id18" x="170" y="0">
			<name x="153" y="8">done</name>
			<label kind="invariant" x="136" y="-34">tcover'==0</label>
		</location>
		<location id="id19" x="0" y="0">
			<name x="-17" y="8">apply</name>
			<committed/>
		</location>
		<location id="id20" x="-246" y="-102">
			<committed/>
		</location>
		<location id="id21" x="-374" y="0">
			<urgent/>
		</location>
		<init ref="id21"/>
		<transition id="id22">
			<source ref="id21"/>
			<target ref="id17"/>
			<label kind="assignment" x="-331" y="0">inits()</label>
		</transition>
		<transition id="id23">
			<source ref="id20"/>
			<target ref="id17"/>
			<label kind="select" x="-238" y="-68">i: int[range_min, range_max]</label>
			<label kind="assignment" x="-238" y="-51">bits[i] ^= 1, idx=i</label>
		</transition>
		<transition id="id24">
			<source ref="id16"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-212" y="-102">cmpDone?</label>
		</transition>
		<transition id="id25">
			<source ref="id19"/>
			<target ref="id16"/>
			<label kind="guard" x="-93" y="-93">!inCovered()</label>
			<nail x="0" y="-102"/>
		</transition>
		<transition id="id26">
			<source ref="id17"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-153" y="-25">update!</label>
			<label kind="assignment" x="-144" y="0">f(idx)</label>
		</transition>
		<transition id="id27">
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="guard" x="42" y="-25">inCovered()</label>
			<label kind="assignment" x="34" y="0">allCovered=true</label>
		</transition>
	</template>
	<template>
		<name>tmul2_tb_random</name>
		<parameter>const int &amp;PIxy[NPI], const int dly, const double covratio</parameter>
		<declaration>clock x;
clock tcover;
int input=0;
int nsame=0, inSame=0;
double rCover;
int idx=0;

bool inCoverSet[NTV];

int covered()
{
    int cnt=0;

    for(i: int[0,NTV-1])
    {
        if(inCoverSet[i]) {
            cnt++;
        }
    }

    bitsCovered=cnt;

    return cnt;
}

int bin2dec()
{
    int[0, MAX_INT] result=0;
    int i;
    for(i=0; i&lt;NPI; i++){
        result += bits[i]*TBL_PWR2[i];
    }

    return result;
}


bool inCovered()
{
  return forall (i : int[0,NTV-1]) inCoverSet[i];    
}

void f(int i){
    int j;
    int[0, MAX_INT] imax = fint(exp2(NPI));

//    rnd = random(100);
//    rnd = random_arcsine(-10,10);
//    rnd = random_beta(0.1,5);
//    rnd = random_gamma(0.5,5);
//    rnd = random_normal(10,1);
//    rnd = random_poisson(1.0);
//    rnd = random_weibull(0.5,5);
//    rnd = random_tri(0,10,100);

    j=fint(random(NPI));                   // pro (NPI) je out 0...NPI-1
 //   j=fint(random_normal(NPI/2.0,0.5));    // pro (NPI/2.0, 0.5) je out NPI/2 +- 0.5
 //   j=fint(random_poisson(1.0));           // pro (1.0) je out 1.0 +- 
//    j=fint(random_arcsine(0.0, NPI-1));    // pro (0.0, NPI-1) je out mezi 0...NPI-1 (aka random())
  //  j=fint(random_tri(0.0, 0.5, NPI-1));    // pro (0.0, 0.5, NPI-1) je out mezi 0...NPI-1 (aka random()), se stredem u 0.5
  //  j = fint(random_weibull(10, 3.0));    // pro (10.0, 3.0) je out mezi 0...3 (aka random()), se stredem vys (pro 10)
  //  j = fint(random_gamma(1.0,0.5));    // pro (1.0, 0.5) je out mezi 0...5 (aka random()), se stredem niz (kolem 1.0)
    if(j &lt; 0) j=0;
    if(j &gt; (NPI-1)) j=NPI-1;
    bits[j] ^= 1;

   if(inCoverSet[input]) { inSame = -1*input; nsame++; }
   else inSame = input;
   inCoverSet[bin2dec()] = true;
    covered();

    rCover = 100.0*bitsCovered / NTV; 

    inCoverage = 0.0;
}

void inits(){
    int i;
    for(i:int[0,MAX_INNER_NODES-1]){ nodes[i].flag=false; }
    for(i:int[0,NPI-1]){
        if(exists(j:int[0,NPI-1]) PIxy[j]==i){ 
            nodes[i].flag=true;    
            nodes[i].dly=0;        
        }
        approxCircNodes++;
    }
    for(i=0; i&lt;approxCircGates; i++) gates[i].flag=false;
    while(exists(i:int[0,MAX_INNER_GATES-1]) (gates[i].flag==false &amp;&amp; i&lt;approxCircGates)){
        approxCircDepth++;
        for(i=0; i&lt;approxCircGates; i++) {
            if(!gates[i].flag &amp;&amp; nodes[gates[i].in0].flag &amp;&amp; nodes[gates[i].in1].flag){  
                nodes[gates[i].out0].dly = (nodes[gates[i].in0].dly&gt;nodes[gates[i].in1].dly?nodes[gates[i].in0].dly:nodes[gates[i].in1].dly) + duration(tbl_op[i]);
                nodes[gates[i].out0].flag=true;
                approxCircNodes++;
                if(nodes[gates[i].out0].dly&gt;approxCircDly){ approxCircDly=nodes[gates[i].out0].dly; }

                gates[i].flag=true; 
            }  
        }
    }
}</declaration>
		<location id="id28" x="-119" y="-102">
			<name x="-129" y="-136">wait</name>
		</location>
		<location id="id29" x="-246" y="0">
			<name x="-255" y="8">get</name>
			<committed/>
		</location>
		<location id="id30" x="170" y="0">
			<name x="153" y="8">done</name>
			<label kind="invariant" x="136" y="-34">tcover'==0</label>
		</location>
		<location id="id31" x="0" y="0">
			<name x="-17" y="8">apply</name>
			<committed/>
		</location>
		<location id="id32" x="-246" y="-102">
			<committed/>
		</location>
		<location id="id33" x="-374" y="0">
			<urgent/>
		</location>
		<init ref="id33"/>
		<transition id="id34">
			<source ref="id33"/>
			<target ref="id29"/>
			<label kind="assignment" x="-331" y="0">inits()</label>
		</transition>
		<transition id="id35">
			<source ref="id32"/>
			<target ref="id29"/>
		</transition>
		<transition id="id36">
			<source ref="id28"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="-212" y="-102">cmpDone?</label>
		</transition>
		<transition id="id37">
			<source ref="id31"/>
			<target ref="id28"/>
			<label kind="guard" x="-93" y="-93">!inCovered()</label>
			<nail x="0" y="-102"/>
		</transition>
		<transition id="id38">
			<source ref="id29"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="-153" y="-25">update!</label>
			<label kind="assignment" x="-144" y="0">f(idx)</label>
		</transition>
		<transition id="id39">
			<source ref="id31"/>
			<target ref="id30"/>
			<label kind="guard" x="42" y="-25">inCovered()</label>
			<label kind="assignment" x="34" y="0">allCovered=true</label>
		</transition>
	</template>
	<template>
		<name>syncPrimary</name>
		<declaration>int idx;</declaration>
		<location id="id40" x="-748" y="-306">
		</location>
		<location id="id41" x="-646" y="-306">
			<committed/>
		</location>
		<location id="id42" x="-510" y="-306">
			<committed/>
		</location>
		<init ref="id40"/>
		<transition id="id43">
			<source ref="id42"/>
			<target ref="id40"/>
			<label kind="guard" x="-646" y="-399">idx&gt;=NPI</label>
			<nail x="-510" y="-374"/>
			<nail x="-748" y="-374"/>
		</transition>
		<transition id="id44">
			<source ref="id42"/>
			<target ref="id41"/>
			<label kind="guard" x="-595" y="-323">idx&lt;NPI</label>
			<nail x="-578" y="-272"/>
		</transition>
		<transition id="id45">
			<source ref="id41"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-612" y="-340">change[idx]!</label>
			<label kind="assignment" x="-629" y="-280">idx++</label>
		</transition>
		<transition id="id46">
			<source ref="id40"/>
			<target ref="id41"/>
			<label kind="synchronisation" x="-730" y="-323">update?</label>
			<label kind="assignment" x="-714" y="-306">idx=0</label>
		</transition>
	</template>
	<template>
		<name>eval_diff</name>
		<parameter>const int dly</parameter>
		<declaration>clock x;</declaration>
		<location id="id47" x="-238" y="0">
			<label kind="invariant" x="-297" y="-8">x&lt;=dly</label>
		</location>
		<location id="id48" x="-102" y="0">
			<committed/>
		</location>
		<init ref="id47"/>
		<transition id="id49">
			<source ref="id48"/>
			<target ref="id47"/>
			<label kind="synchronisation" x="-178" y="51">cmpDone!</label>
			<label kind="assignment" x="-246" y="110">outcnt=0, diffctrl=0, x=0</label>
			<nail x="-102" y="110"/>
			<nail x="-238" y="110"/>
		</transition>
		<transition id="id50">
			<source ref="id47"/>
			<target ref="id47"/>
			<label kind="guard" x="-331" y="-93">diffctrl&lt;2
&amp;&amp; x==dly</label>
			<label kind="assignment" x="-289" y="-42">x=0</label>
			<nail x="-263" y="-76"/>
			<nail x="-229" y="-76"/>
		</transition>
		<transition id="id51">
			<source ref="id47"/>
			<target ref="id48"/>
			<label kind="guard" x="-204" y="0">diffctrl==2</label>
			<label kind="assignment" x="-212" y="-68">err_magn_v=0,
err_magn_r=0.0,
diff()</label>
		</transition>
	</template>
	<template>
		<name>gate2</name>
		<parameter>const int id, const int a0, const int a1, const int y0, broadcast chan &amp;cin0, broadcast chan &amp;cin1, broadcast chan &amp;cout0</parameter>
		<declaration>clock x;

void inits(){
    int i;

    // collect info about the approx.circuit topology 
    gates[id].active = true;
    gates[id].in0 = a0; 
    gates[id].in1 = a1; 
    gates[id].inAvail = 0; 
    gates[id].out0 = y0; 
    gates[id].dly = duration(tbl_op[id]);
    gates[id].depth = -1;
    gates[id].flag = false;

    approxCircGates++;    
}

void outGen(tOp op){
 //   outSync(y0);

    if(op == OP_AND){
        bits[y0] = bits[a0] &amp; bits[a1];        
    }
    else if(op == OP_NAND){
        bits[y0] = not (bits[a0] &amp; bits[a1]);        
    }
    else if(op == OP_OR){
        bits[y0] = bits[a0] | bits[a1];        
    }
    else if(op == OP_NOR){
        bits[y0] = not (bits[a0] | bits[a1]);        
    }
    else if(op == OP_XOR){
        bits[y0] = (bits[a0] != bits[a1]);        
    }
    else if(op == OP_XNOR){
        bits[y0] = (bits[a0] == bits[a1]);
    }
    else if(op == OP_SET){
        //not really a gate but should be fine
        bits[y0] = bits[a0];
    }
    else {    // unsupported operation
    }

    if(id==2){ 
        if(diffctrl&lt;2) diffctrl++;
    }  
}</declaration>
		<location id="id52" x="-170" y="0">
		</location>
		<location id="id53" x="0" y="0">
			<label kind="invariant" x="-17" y="17">x&lt;=duration(tbl_op[id])</label>
		</location>
		<location id="id54" x="-272" y="0">
			<committed/>
		</location>
		<init ref="id54"/>
		<transition id="id55">
			<source ref="id54"/>
			<target ref="id52"/>
			<label kind="assignment" x="-238" y="0">inits()</label>
		</transition>
		<transition id="id56">
			<source ref="id52"/>
			<target ref="id53"/>
			<label kind="synchronisation" x="-144" y="0">cin1?</label>
			<label kind="assignment" x="-76" y="0">x=0</label>
			<nail x="-85" y="0"/>
		</transition>
		<transition id="id57">
			<source ref="id53"/>
			<target ref="id52"/>
			<label kind="guard" x="-110" y="-127">x==duration(tbl_op[id])</label>
			<label kind="synchronisation" x="8" y="-68">cout0!</label>
			<label kind="assignment" x="-144" y="-102">outGen(tbl_op[id])</label>
			<nail x="0" y="-102"/>
			<nail x="-170" y="-102"/>
		</transition>
		<transition id="id58">
			<source ref="id52"/>
			<target ref="id53"/>
			<label kind="synchronisation" x="-136" y="-42">cin0?</label>
			<label kind="assignment" x="-59" y="-42">x=0</label>
			<nail x="-85" y="-34"/>
		</transition>
	</template>
	<system>
// Place template instantiations here.

synPri = syncPrimary();
mul2A = tmul2any(PIxy, POx, tbl_acc_any, DLY_MUL2);

//mul2Atb = tmul2_tb_exhaust(PIxy, DLY_MUL2, COVERAGE_RATIO);
//mul2Atb = tmul2_tb_nondet(PIxy[0], PIxy[7], DLY_MUL2, COVERAGE_RATIO);
mul2Atb = tmul2_tb_random(PIxy, DLY_MUL2, COVERAGE_RATIO);

ediff = eval_diff(5);

//gates
g22 = gate2(0, PIxy[14], PIxy[0], 22, change[14], change[0], change[22]);
g23 = gate2(1, PIxy[15], PIxy[0], 23, change[15], change[0], change[23]);
g28 = gate2(2, PIxy[12], PIxy[1], 28, change[12], change[1], change[28]);
g29 = gate2(3, PIxy[13], PIxy[1], 29, change[13], change[1], change[29]);
g30 = gate2(4, PIxy[14], PIxy[1], 30, change[14], change[1], change[30]);
g31 = gate2(5, PIxy[15], PIxy[1], 31, change[15], change[1], change[31]);
g40 = gate2(6, PIxy[0], PIxy[1], 40, change[0], change[1], change[40]);
g41 = gate2(7, PIxy[0], 28, 41, change[0], change[28], change[41]);
g42 = gate2(8, 22, 29, 42, change[22], change[29], change[42]);
g43 = gate2(9, 22, 29, 43, change[22], change[29], change[43]);
g44 = gate2(10, 23, 30, 44, change[23], change[30], change[44]);
g45 = gate2(11, 23, 30, 45, change[23], change[30], change[45]);
g49 = gate2(12, PIxy[11], PIxy[2], 49, change[11], change[2], change[49]);
g50 = gate2(13, PIxy[12], PIxy[2], 50, change[12], change[2], change[50]);
g51 = gate2(14, PIxy[13], PIxy[2], 51, change[13], change[2], change[51]);
g52 = gate2(15, PIxy[14], PIxy[2], 52, change[14], change[2], change[52]);
g53 = gate2(16, PIxy[15], PIxy[2], 53, change[15], change[2], change[53]);
g70 = gate2(17, 40, 49, 70, change[40], change[49], change[70]);
g74 = gate2(18, 42, 50, 74, change[42], change[50], change[74]);
g75 = gate2(19, 42, 50, 75, change[42], change[50], change[75]);
g76 = gate2(20, 74, 41, 76, change[74], change[41], change[76]);
g77 = gate2(21, 74, 41, 77, change[74], change[41], change[77]);
g78 = gate2(22, 75, 76, 78, change[75], change[76], change[78]);
g79 = gate2(23, 44, 51, 79, change[44], change[51], change[79]);
g80 = gate2(24, 44, 51, 80, change[44], change[51], change[80]);
g81 = gate2(25, 79, 43, 81, change[79], change[43], change[81]);
g82 = gate2(26, 79, 43, 82, change[79], change[43], change[82]);
g83 = gate2(27, 80, 81, 83, change[80], change[81], change[83]);
g84 = gate2(28, 31, 52, 84, change[31], change[52], change[84]);
g85 = gate2(29, 31, 52, 85, change[31], change[52], change[85]);
g87 = gate2(30, 84, 45, 87, change[84], change[45], change[87]);
g88 = gate2(31, 85, 45, 88, change[85], change[45], change[88]);
g92 = gate2(32, PIxy[11], PIxy[3], 92, change[11], change[3], change[92]);
g93 = gate2(33, PIxy[12], PIxy[3], 93, change[12], change[3], change[93]);
g94 = gate2(34, PIxy[13], PIxy[3], 94, change[13], change[3], change[94]);
g95 = gate2(35, PIxy[14], PIxy[3], 95, change[14], change[3], change[95]);
g96 = gate2(36, PIxy[15], PIxy[3], 96, change[15], change[3], change[96]);
g108 = gate2(37, PIxy[3], PIxy[10], 108, change[3], change[10], change[108]);
g112 = gate2(38, 77, 92, 112, change[77], change[92], change[112]);
g113 = gate2(39, 77, 92, 113, change[77], change[92], change[113]);
g114 = gate2(40, 112, 70, 114, change[112], change[70], change[114]);
g115 = gate2(41, 112, 70, 115, change[112], change[70], change[115]);
g116 = gate2(42, 113, 114, 116, change[113], change[114], change[116]);
g117 = gate2(43, 82, 93, 117, change[82], change[93], change[117]);
g118 = gate2(44, 82, 93, 118, change[82], change[93], change[118]);
g119 = gate2(45, 117, 78, 119, change[117], change[78], change[119]);
g120 = gate2(46, 117, 78, 120, change[117], change[78], change[120]);
g121 = gate2(47, 118, 119, 121, change[118], change[119], change[121]);
g122 = gate2(48, 87, 94, 122, change[87], change[94], change[122]);
g123 = gate2(49, 87, 94, 123, change[87], change[94], change[123]);
g124 = gate2(50, 122, 83, 124, change[122], change[83], change[124]);
g125 = gate2(51, 122, 83, 125, change[122], change[83], change[125]);
g126 = gate2(52, 123, 124, 126, change[123], change[124], change[126]);
g127 = gate2(53, 53, 95, 127, change[53], change[95], change[127]);
g128 = gate2(54, 53, 95, 128, change[53], change[95], change[128]);
g129 = gate2(55, 127, 88, 129, change[127], change[88], change[129]);
g130 = gate2(56, 127, 88, 130, change[127], change[88], change[130]);
g131 = gate2(57, 128, 129, 131, change[128], change[129], change[131]);
g134 = gate2(58, PIxy[10], PIxy[4], 134, change[10], change[4], change[134]);
g135 = gate2(59, PIxy[11], PIxy[4], 135, change[11], change[4], change[135]);
g136 = gate2(60, PIxy[12], PIxy[4], 136, change[12], change[4], change[136]);
g137 = gate2(61, PIxy[13], PIxy[4], 137, change[13], change[4], change[137]);
g138 = gate2(62, PIxy[14], PIxy[4], 138, change[14], change[4], change[138]);
g139 = gate2(63, PIxy[15], PIxy[4], 139, change[15], change[4], change[139]);
g150 = gate2(64, 115, 134, 150, change[115], change[134], change[150]);
g151 = gate2(65, 115, 134, 151, change[115], change[134], change[151]);
g152 = gate2(66, 150, 108, 152, change[150], change[108], change[152]);
g153 = gate2(67, 150, 108, 153, change[150], change[108], change[153]);
g154 = gate2(68, 151, 152, 154, change[151], change[152], change[154]);
g155 = gate2(69, 120, 135, 155, change[120], change[135], change[155]);
g156 = gate2(70, 120, 135, 156, change[120], change[135], change[156]);
g157 = gate2(71, 155, 116, 157, change[155], change[116], change[157]);
g158 = gate2(72, 155, 116, 158, change[155], change[116], change[158]);
g159 = gate2(73, 156, 157, 159, change[156], change[157], change[159]);
g160 = gate2(74, 125, 136, 160, change[125], change[136], change[160]);
g161 = gate2(75, 125, 136, 161, change[125], change[136], change[161]);
g162 = gate2(76, 160, 121, 162, change[160], change[121], change[162]);
g163 = gate2(77, 160, 121, 163, change[160], change[121], change[163]);
g164 = gate2(78, 161, 162, 164, change[161], change[162], change[164]);
g165 = gate2(79, 130, 137, 165, change[130], change[137], change[165]);
g166 = gate2(80, 130, 137, 166, change[130], change[137], change[166]);
g167 = gate2(81, 165, 126, 167, change[165], change[126], change[167]);
g168 = gate2(82, 165, 126, 168, change[165], change[126], change[168]);
g169 = gate2(83, 166, 167, 169, change[166], change[167], change[169]);
g170 = gate2(84, 96, 138, 170, change[96], change[138], change[170]);
g171 = gate2(85, 96, 138, 171, change[96], change[138], change[171]);
g172 = gate2(86, 170, 131, 172, change[170], change[131], change[172]);
g173 = gate2(87, 170, 131, 173, change[170], change[131], change[173]);
g174 = gate2(88, 171, 172, 174, change[171], change[172], change[174]);
g176 = gate2(89, PIxy[9], PIxy[5], 176, change[9], change[5], change[176]);
g177 = gate2(90, PIxy[10], PIxy[5], 177, change[10], change[5], change[177]);
g178 = gate2(91, PIxy[11], PIxy[5], 178, change[11], change[5], change[178]);
g179 = gate2(92, PIxy[12], PIxy[5], 179, change[12], change[5], change[179]);
g180 = gate2(93, PIxy[13], PIxy[5], 180, change[13], change[5], change[180]);
g181 = gate2(94, PIxy[14], PIxy[5], 181, change[14], change[5], change[181]);
g182 = gate2(95, PIxy[15], PIxy[5], 182, change[15], change[5], change[182]);
g189 = gate2(96, 153, 176, 189, change[153], change[176], change[189]);
g190 = gate2(97, 176, PIxy[4], 190, change[176], change[4], change[190]);
g192 = gate2(98, 189, 190, 192, change[189], change[190], change[192]);
g193 = gate2(99, 158, 177, 193, change[158], change[177], change[193]);
g194 = gate2(100, 158, 177, 194, change[158], change[177], change[194]);
g195 = gate2(101, 193, 154, 195, change[193], change[154], change[195]);
g196 = gate2(102, 193, 154, 196, change[193], change[154], change[196]);
g197 = gate2(103, 194, 195, 197, change[194], change[195], change[197]);
g198 = gate2(104, 163, 178, 198, change[163], change[178], change[198]);
g199 = gate2(105, 163, 178, 199, change[163], change[178], change[199]);
g200 = gate2(106, 198, 159, 200, change[198], change[159], change[200]);
g201 = gate2(107, 198, 159, 201, change[198], change[159], change[201]);
g202 = gate2(108, 199, 200, 202, change[199], change[200], change[202]);
g203 = gate2(109, 168, 179, 203, change[168], change[179], change[203]);
g204 = gate2(110, 168, 179, 204, change[168], change[179], change[204]);
g205 = gate2(111, 203, 164, 205, change[203], change[164], change[205]);
g206 = gate2(112, 203, 164, 206, change[203], change[164], change[206]);
g207 = gate2(113, 204, 205, 207, change[204], change[205], change[207]);
g208 = gate2(114, 173, 180, 208, change[173], change[180], change[208]);
g209 = gate2(115, 173, 180, 209, change[173], change[180], change[209]);
g210 = gate2(116, 208, 169, 210, change[208], change[169], change[210]);
g211 = gate2(117, 208, 169, 211, change[208], change[169], change[211]);
g212 = gate2(118, 209, 210, 212, change[209], change[210], change[212]);
g213 = gate2(119, 139, 181, 213, change[139], change[181], change[213]);
g214 = gate2(120, 139, 181, 214, change[139], change[181], change[214]);
g215 = gate2(121, 213, 174, 215, change[213], change[174], change[215]);
g216 = gate2(122, 213, 174, 216, change[213], change[174], change[216]);
g217 = gate2(123, 214, 215, 217, change[214], change[215], change[217]);
g218 = gate2(124, PIxy[8], PIxy[6], 218, change[8], change[6], change[218]);
g219 = gate2(125, PIxy[9], PIxy[6], 219, change[9], change[6], change[219]);
g220 = gate2(126, PIxy[10], PIxy[6], 220, change[10], change[6], change[220]);
g221 = gate2(127, PIxy[11], PIxy[6], 221, change[11], change[6], change[221]);
g222 = gate2(128, PIxy[12], PIxy[6], 222, change[12], change[6], change[222]);
g223 = gate2(129, PIxy[13], PIxy[6], 223, change[13], change[6], change[223]);
g224 = gate2(130, PIxy[14], PIxy[6], 224, change[14], change[6], change[224]);
g225 = gate2(131, PIxy[15], PIxy[6], 225, change[15], change[6], change[225]);
g229 = gate2(132, 218, 218, 229, change[218], change[999], change[229]);
g231 = gate2(133, 196, 219, 231, change[196], change[219], change[231]);
g232 = gate2(134, 196, 219, 232, change[196], change[219], change[232]);
g233 = gate2(135, 231, 192, 233, change[231], change[192], change[233]);
g234 = gate2(136, 231, 192, 234, change[231], change[192], change[234]);
g235 = gate2(137, 232, 233, 235, change[232], change[233], change[235]);
g236 = gate2(138, 201, 220, 236, change[201], change[220], change[236]);
g237 = gate2(139, 201, 220, 237, change[201], change[220], change[237]);
g238 = gate2(140, 236, 197, 238, change[236], change[197], change[238]);
g239 = gate2(141, 236, 197, 239, change[236], change[197], change[239]);
g240 = gate2(142, 237, 238, 240, change[237], change[238], change[240]);
g241 = gate2(143, 206, 221, 241, change[206], change[221], change[241]);
g242 = gate2(144, 206, 221, 242, change[206], change[221], change[242]);
g243 = gate2(145, 241, 202, 243, change[241], change[202], change[243]);
g244 = gate2(146, 241, 202, 244, change[241], change[202], change[244]);
g245 = gate2(147, 242, 243, 245, change[242], change[243], change[245]);
g246 = gate2(148, 211, 222, 246, change[211], change[222], change[246]);
g247 = gate2(149, 211, 222, 247, change[211], change[222], change[247]);
g248 = gate2(150, 246, 207, 248, change[246], change[207], change[248]);
g249 = gate2(151, 246, 207, 249, change[246], change[207], change[249]);
g250 = gate2(152, 247, 248, 250, change[247], change[248], change[250]);
g251 = gate2(153, 216, 223, 251, change[216], change[223], change[251]);
g252 = gate2(154, 216, 223, 252, change[216], change[223], change[252]);
g253 = gate2(155, 251, 212, 253, change[251], change[212], change[253]);
g254 = gate2(156, 251, 212, 254, change[251], change[212], change[254]);
g255 = gate2(157, 252, 253, 255, change[252], change[253], change[255]);
g256 = gate2(158, 182, 224, 256, change[182], change[224], change[256]);
g257 = gate2(159, 182, 224, 257, change[182], change[224], change[257]);
g258 = gate2(160, 256, 217, 258, change[256], change[217], change[258]);
g259 = gate2(161, 256, 217, 259, change[256], change[217], change[259]);
g260 = gate2(162, 257, 258, 260, change[257], change[258], change[260]);
g261 = gate2(163, PIxy[8], PIxy[7], 261, change[8], change[7], change[261]);
g262 = gate2(164, PIxy[9], PIxy[7], 262, change[9], change[7], change[262]);
g263 = gate2(165, PIxy[10], PIxy[7], 263, change[10], change[7], change[263]);
g264 = gate2(166, PIxy[11], PIxy[7], 264, change[11], change[7], change[264]);
g265 = gate2(167, PIxy[12], PIxy[7], 265, change[12], change[7], change[265]);
g266 = gate2(168, PIxy[13], PIxy[7], 266, change[13], change[7], change[266]);
g267 = gate2(169, PIxy[14], PIxy[7], 267, change[14], change[7], change[267]);
g268 = gate2(170, PIxy[15], PIxy[7], 268, change[15], change[7], change[268]);
g269 = gate2(171, 234, 261, 269, change[234], change[261], change[269]);
g270 = gate2(172, 234, 261, 270, change[234], change[261], change[270]);
g271 = gate2(173, 269, 218, 271, change[269], change[218], change[271]);
g272 = gate2(174, 269, 218, 272, change[269], change[218], change[272]);
g273 = gate2(175, 270, 271, 273, change[270], change[271], change[273]);
g274 = gate2(176, 239, 262, 274, change[239], change[262], change[274]);
g275 = gate2(177, 239, 262, 275, change[239], change[262], change[275]);
g276 = gate2(178, 274, 235, 276, change[274], change[235], change[276]);
g277 = gate2(179, 274, 235, 277, change[274], change[235], change[277]);
g278 = gate2(180, 275, 276, 278, change[275], change[276], change[278]);
g279 = gate2(181, 244, 263, 279, change[244], change[263], change[279]);
g280 = gate2(182, 244, 263, 280, change[244], change[263], change[280]);
g281 = gate2(183, 279, 240, 281, change[279], change[240], change[281]);
g282 = gate2(184, 279, 240, 282, change[279], change[240], change[282]);
g283 = gate2(185, 280, 281, 283, change[280], change[281], change[283]);
g284 = gate2(186, 249, 264, 284, change[249], change[264], change[284]);
g285 = gate2(187, 249, 264, 285, change[249], change[264], change[285]);
g286 = gate2(188, 284, 245, 286, change[284], change[245], change[286]);
g287 = gate2(189, 284, 245, 287, change[284], change[245], change[287]);
g288 = gate2(190, 285, 286, 288, change[285], change[286], change[288]);
g289 = gate2(191, 254, 265, 289, change[254], change[265], change[289]);
g290 = gate2(192, 254, 265, 290, change[254], change[265], change[290]);
g291 = gate2(193, 289, 250, 291, change[289], change[250], change[291]);
g292 = gate2(194, 289, 250, 292, change[289], change[250], change[292]);
g293 = gate2(195, 290, 291, 293, change[290], change[291], change[293]);
g294 = gate2(196, 259, 266, 294, change[259], change[266], change[294]);
g295 = gate2(197, 259, 266, 295, change[259], change[266], change[295]);
g296 = gate2(198, 294, 255, 296, change[294], change[255], change[296]);
g297 = gate2(199, 294, 255, 297, change[294], change[255], change[297]);
g298 = gate2(200, 295, 296, 298, change[295], change[296], change[298]);
g299 = gate2(201, 225, 267, 299, change[225], change[267], change[299]);
g300 = gate2(202, 225, 267, 300, change[225], change[267], change[300]);
g301 = gate2(203, 299, 260, 301, change[299], change[260], change[301]);
g302 = gate2(204, 299, 260, 302, change[299], change[260], change[302]);
g303 = gate2(205, 300, 301, 303, change[300], change[301], change[303]);
g304 = gate2(206, 277, 273, 304, change[277], change[273], change[304]);
g305 = gate2(207, 277, 273, 305, change[277], change[273], change[305]);
g306 = gate2(208, 282, 278, 306, change[282], change[278], change[306]);
g307 = gate2(209, 282, 278, 307, change[282], change[278], change[307]);
g308 = gate2(210, 306, 305, 308, change[306], change[305], change[308]);
g309 = gate2(211, 306, 305, 309, change[306], change[305], change[309]);
g310 = gate2(212, 307, 308, 310, change[307], change[308], change[310]);
g311 = gate2(213, 287, 283, 311, change[287], change[283], change[311]);
g312 = gate2(214, 287, 283, 312, change[287], change[283], change[312]);
g313 = gate2(215, 311, 310, 313, change[311], change[310], change[313]);
g314 = gate2(216, 311, 310, 314, change[311], change[310], change[314]);
g315 = gate2(217, 312, 313, 315, change[312], change[313], change[315]);
g316 = gate2(218, 292, 288, 316, change[292], change[288], change[316]);
g317 = gate2(219, 292, 288, 317, change[292], change[288], change[317]);
g318 = gate2(220, 316, 315, 318, change[316], change[315], change[318]);
g319 = gate2(221, 316, 315, 319, change[316], change[315], change[319]);
g320 = gate2(222, 317, 318, 320, change[317], change[318], change[320]);
g321 = gate2(223, 297, 293, 321, change[297], change[293], change[321]);
g322 = gate2(224, 297, 293, 322, change[297], change[293], change[322]);
g323 = gate2(225, 321, 320, 323, change[321], change[320], change[323]);
g324 = gate2(226, 321, 320, 324, change[321], change[320], change[324]);
g325 = gate2(227, 322, 323, 325, change[322], change[323], change[325]);
g326 = gate2(228, 302, 298, 326, change[302], change[298], change[326]);
g327 = gate2(229, 302, 298, 327, change[302], change[298], change[327]);
g328 = gate2(230, 326, 325, 328, change[326], change[325], change[328]);
g329 = gate2(231, 326, 325, 329, change[326], change[325], change[329]);
g330 = gate2(232, 327, 328, 330, change[327], change[328], change[330]);
g331 = gate2(233, 268, 303, 331, change[268], change[303], change[331]);
g332 = gate2(234, PIxy[7], 303, 332, change[7], change[303], change[332]);
g333 = gate2(235, 331, 330, 333, change[331], change[330], change[333]);
g334 = gate2(236, 331, 330, 334, change[331], change[330], change[334]);
g335 = gate2(237, 332, 333, 335, change[332], change[333], change[335]);
g336 = gate2(238, PIxy[8], PIxy[8], POy[4], change[8], change[999], change[336]);
g337 = gate2(239, PIxy[8], PIxy[8], POy[2], change[8], change[999], change[337]);

// List one or more processes to be composed into a system.
system
synPri,
mul2A, 
mul2Atb,
ediff,
g22,
g23,
g28,
g29,
g30,
g31,
g40,
g41,
g42,
g43,
g44,
g45,
g49,
g50,
g51,
g52,
g53,
g70,
g74,
g75,
g76,
g77,
g78,
g79,
g80,
g81,
g82,
g83,
g84,
g85,
g87,
g88,
g92,
g93,
g94,
g95,
g96,
g108,
g112,
g113,
g114,
g115,
g116,
g117,
g118,
g119,
g120,
g121,
g122,
g123,
g124,
g125,
g126,
g127,
g128,
g129,
g130,
g131,
g134,
g135,
g136,
g137,
g138,
g139,
g150,
g151,
g152,
g153,
g154,
g155,
g156,
g157,
g158,
g159,
g160,
g161,
g162,
g163,
g164,
g165,
g166,
g167,
g168,
g169,
g170,
g171,
g172,
g173,
g174,
g176,
g177,
g178,
g179,
g180,
g181,
g182,
g189,
g190,
g192,
g193,
g194,
g195,
g196,
g197,
g198,
g199,
g200,
g201,
g202,
g203,
g204,
g205,
g206,
g207,
g208,
g209,
g210,
g211,
g212,
g213,
g214,
g215,
g216,
g217,
g218,
g219,
g220,
g221,
g222,
g223,
g224,
g225,
g229,
g231,
g232,
g233,
g234,
g235,
g236,
g237,
g238,
g239,
g240,
g241,
g242,
g243,
g244,
g245,
g246,
g247,
g248,
g249,
g250,
g251,
g252,
g253,
g254,
g255,
g256,
g257,
g258,
g259,
g260,
g261,
g262,
g263,
g264,
g265,
g266,
g267,
g268,
g269,
g270,
g271,
g272,
g273,
g274,
g275,
g276,
g277,
g278,
g279,
g280,
g281,
g282,
g283,
g284,
g285,
g286,
g287,
g288,
g289,
g290,
g291,
g292,
g293,
g294,
g295,
g296,
g297,
g298,
g299,
g300,
g301,
g302,
g303,
g304,
g305,
g306,
g307,
g308,
g309,
g310,
g311,
g312,
g313,
g314,
g315,
g316,
g317,
g318,
g319,
g320,
g321,
g322,
g323,
g324,
g325,
g326,
g327,
g328,
g329,
g330,
g331,
g332,
g333,
g334,
g335,
g336,
g337;
</system>
	<queries>
		<query>
			<formula>E[&lt;=25000; 10] (max:mul2Atb.tcover)
			</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=350; 100] (max:bitsCovered)
			</formula>
			<comment/>
			<result outcome="success" type="quantity" value="16.92 ± 0.0610112 (95% CI)" timestamp="2024-02-20 23:49:16 +0100">
				<details>16.92 ± 0.0610112 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="max: bitsCovered" yaxis="probability density">
					<series title="density" type="b(1.000000)" color="0x0000ff" encoding="csv">16.0,0.09
17.0,0.9
18.0,0.01
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">16.92,0.0
16.92,0.9
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=3
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [16, 18]
Mean estimate of displayed sample: 16.92 ± 0.061011 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="max: bitsCovered" yaxis="probability">
					<series title="probability" type="b(1.000000)" color="0x0000ff" encoding="csv">16.0,0.09
17.0,0.9
18.0,0.01
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">16.92,0.0
16.92,0.9
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=3
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [16, 18]
Mean estimate of displayed sample: 16.92 ± 0.061011 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="max: bitsCovered" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">16.0,0.0
17.0,0.09
18.0,0.99
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">16.92,0.0
16.92,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=3
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [16, 18]
Mean estimate of displayed sample: 16.92 ± 0.061011 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="max: bitsCovered" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">16.0,0.03621669264517642
17.0,0.16398225502963523
18.0,0.9997468539670226
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">16.0,0.0
17.0,0.04198359562839223
18.0,0.9455406146079194
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">16.0,0.0
17.0,0.09
18.0,0.99
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">16.92,0.0
16.92,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=3
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [16, 18]
Mean estimate of displayed sample: 16.92 ± 0.061011 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="max: bitsCovered" yaxis="count">
					<series title="count" type="b(1.000000)" color="0x0000ff" encoding="csv">16.0,9.0
17.0,90.0
18.0,1.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">16.92,0.0
16.92,90.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=3
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [16, 18]
Mean estimate of displayed sample: 16.92 ± 0.061011 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=25000] (&lt;&gt;bitsCovered&gt;14)
			</formula>
			<comment/>
			<result outcome="success" type="interval" value="≥ 0.950056 (95% CI)" timestamp="2024-02-28 12:17:49 +0100">
				<details>≥ 0.950056 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="run duration in time" yaxis="probability density">
					<series title="density" type="b(2.905407)" color="0x0000ff" encoding="csv">286.63313006749377,0.023901792098791095
289.5385375012718,0.05258394261734041
292.4439449350498,0.06692501787661506
295.34935236882785,0.06692501787661506
298.25475980260586,0.04780358419758219
301.16016723638387,0.05736430103709863
304.0655746701619,0.014341075259274657
306.97098210393995,0.004780358419758219
309.87638953771796,0.009560716839516438
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">297.04049171814916,0.0
297.04049171814916,0.06692501787661506
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.9054, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [286.63, 312.78]
Mean estimate of displayed sample: 297.04 ± 1.3275 (95% CI)</comment>
				</plot>
				<plot title="Probability Density Confidence Intervals" xaxis="run duration in time" yaxis="probability density">
					<series title="upper limit" type="b(2.905407)" color="0xa0a0ff" encoding="csv">286.63313006749377,0.15466731481612306
289.5385375012718,0.2569401232482781
292.4439449350498,0.30466893329868333
295.34935236882785,0.30466893329868333
298.25475980260586,0.24062593250302433
301.16016723638387,0.27303927891193064
304.0655746701619,0.11697481982594136
306.97098210393995,0.07497131085391912
309.87638953771796,0.09676728911341523
					</series>
					<series title="lower limit" type="b(2.905407)" color="0x0000ff" encoding="csv">286.63313006749377,0.022931659153745478
289.5385375012718,0.07881196318794174
292.4439449350498,0.1105837866784895
295.34935236882785,0.1105837866784895
298.25475980260586,0.06866420769681664
301.16016723638387,0.08919640600812592
304.0655746701619,0.008676497316343764
306.97098210393995,3.515744052335976E-4
309.87638953771796,0.0033819003261732383
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">297.04049171814916,0.0
297.04049171814916,0.10486272243838436
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.9054, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [286.63, 312.78]
Mean estimate of displayed sample: 297.04 ± 1.3275 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="probability" type="b(2.905407)" color="0x0000ff" encoding="csv">286.63313006749377,0.06944444444444445
289.5385375012718,0.1527777777777778
292.4439449350498,0.19444444444444445
295.34935236882785,0.19444444444444445
298.25475980260586,0.1388888888888889
301.16016723638387,0.16666666666666666
304.0655746701619,0.041666666666666664
306.97098210393995,0.013888888888888888
309.87638953771796,0.027777777777777776
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">297.04049171814916,0.0
297.04049171814916,0.19444444444444445
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.9054, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [286.63, 312.78]
Mean estimate of displayed sample: 297.04 ± 1.3275 (95% CI)</comment>
				</plot>
				<plot title="Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="b(2.905407)" color="0xa0a0ff" encoding="csv">286.63313006749377,0.15466731481612306
289.5385375012718,0.2569401232482781
292.4439449350498,0.30466893329868333
295.34935236882785,0.30466893329868333
298.25475980260586,0.24062593250302433
301.16016723638387,0.27303927891193064
304.0655746701619,0.11697481982594136
306.97098210393995,0.07497131085391912
309.87638953771796,0.09676728911341523
					</series>
					<series title="lower limit" type="b(2.905407)" color="0x0000ff" encoding="csv">286.63313006749377,0.022931659153745478
289.5385375012718,0.07881196318794174
292.4439449350498,0.1105837866784895
295.34935236882785,0.1105837866784895
298.25475980260586,0.06866420769681664
301.16016723638387,0.08919640600812592
304.0655746701619,0.008676497316343764
306.97098210393995,3.515744052335976E-4
309.87638953771796,0.0033819003261732383
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">297.04049171814916,0.0
297.04049171814916,0.30466893329868333
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.9054, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [286.63, 312.78]
Mean estimate of displayed sample: 297.04 ± 1.3275 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">286.63313006749377,0.0
289.5385375012718,0.06944444444444445
292.4439449350498,0.2222222222222222
295.34935236882785,0.4166666666666667
298.25475980260586,0.6111111111111112
301.16016723638387,0.75
304.0655746701619,0.9166666666666666
306.97098210393995,0.9583333333333334
309.87638953771796,0.9722222222222222
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">297.04049171814916,0.0
297.04049171814916,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.9054, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [286.63, 312.78]
Mean estimate of displayed sample: 297.04 ± 1.3275 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">286.63313006749377,0.04994408370585468
289.5385375012718,0.15466731481612306
292.4439449350498,0.3356366278546927
295.34935236882785,0.5388867416042286
298.25475980260586,0.7238453141525445
301.16016723638387,0.844607342645625
304.0655746701619,0.9688024908586155
306.97098210393995,0.9913235026836562
309.87638953771796,0.9966180996738268
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">286.63313006749377,0.0
289.5385375012718,0.022931659153745478
292.4439449350498,0.1326823847878405
295.34935236882785,0.30152116823103925
298.25475980260586,0.48893693622768925
301.16016723638387,0.6339719278620991
304.0655746701619,0.827391415316326
306.97098210393995,0.8830251801740586
309.87638953771796,0.9032327108865847
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">286.63313006749377,0.0
289.5385375012718,0.06944444444444445
292.4439449350498,0.2222222222222222
295.34935236882785,0.4166666666666667
298.25475980260586,0.6111111111111112
301.16016723638387,0.75
304.0655746701619,0.9166666666666666
306.97098210393995,0.9583333333333334
309.87638953771796,0.9722222222222222
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">297.04049171814916,0.0
297.04049171814916,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.9054, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [286.63, 312.78]
Mean estimate of displayed sample: 297.04 ± 1.3275 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="run duration in time" yaxis="count">
					<series title="count" type="b(2.905407)" color="0x0000ff" encoding="csv">286.63313006749377,5.0
289.5385375012718,11.0
292.4439449350498,14.0
295.34935236882785,14.0
298.25475980260586,10.0
301.16016723638387,12.0
304.0655746701619,3.0
306.97098210393995,1.0
309.87638953771796,2.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">297.04049171814916,0.0
297.04049171814916,14.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.9054, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [286.63, 312.78]
Mean estimate of displayed sample: 297.04 ± 1.3275 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>simulate [&lt;=350;1] {bits[0], 2+bits[1], 4+bits[2], 6+bits[3], 8+bits[4], 10+bits[5], 12+bits[6], 14+bits[7], bitsCovered, 16+allCovered}
			</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-02-20 23:49:34 +0100">
				<plot title="Simulations (1)" xaxis="time" yaxis="value">
					<series title="bits[0]" type="l" color="0xff0000" encoding="csv">0.0,0.0
21.48884116555564,0.0
21.48884116555564,1.0
43.419370179763064,1.0
43.419370179763064,0.0
63.419370179763064,0.0
63.419370179763064,1.0
83.64513209089637,1.0
83.64513209089637,0.0
103.64513209089637,0.0
103.64513209089637,1.0
123.64513209089637,1.0
123.64513209089637,0.0
146.39630878111348,0.0
146.39630878111348,1.0
166.39630878111348,1.0
166.39630878111348,0.0
187.9592922620941,0.0
187.9592922620941,1.0
209.99395743594505,1.0
209.99395743594505,0.0
234.01308378712426,0.0
234.01308378712426,1.0
256.5658743326976,1.0
256.5658743326976,0.0
278.7766543858275,0.0
278.7766543858275,1.0
301.9969100044731,1.0
301.9969100044731,0.0
321.99691000447297,0.0
321.99691000447297,1.0
344.13134875023025,1.0
344.13134875023025,0.0
350.0,0.0
					</series>
					<series title="2 + bits[1]" type="l" color="0xff9900" encoding="csv">0.0,2.0
43.419370179763064,2.0
43.419370179763064,3.0
83.64513209089637,3.0
83.64513209089637,2.0
123.64513209089637,2.0
123.64513209089637,3.0
166.39630878111348,3.0
166.39630878111348,2.0
209.99395743594505,2.0
209.99395743594505,3.0
256.5658743326976,3.0
256.5658743326976,2.0
301.9969100044731,2.0
301.9969100044731,3.0
344.13134875023025,3.0
344.13134875023025,2.0
350.0,2.0
					</series>
					<series title="4 + bits[2]" type="l" color="0xccff00" encoding="csv">0.0,4.0
83.64513209089637,4.0
83.64513209089637,5.0
166.39630878111348,5.0
166.39630878111348,4.0
256.5658743326976,4.0
256.5658743326976,5.0
344.13134875023025,5.0
344.13134875023025,4.0
350.0,4.0
					</series>
					<series title="6 + bits[3]" type="l" color="0x33ff00" encoding="csv">0.0,6.0
166.39630878111348,6.0
166.39630878111348,7.0
344.13134875023025,7.0
344.13134875023025,6.0
350.0,6.0
					</series>
					<series title="8 + bits[4]" type="l" color="0x00ff66" encoding="csv">0.0,8.0
344.13134875023025,8.0
344.13134875023025,9.0
350.0,9.0
					</series>
					<series title="10 + bits[5]" type="l" color="0x00ffff" encoding="csv">0.0,10.0
350.0,10.0
					</series>
					<series title="12 + bits[6]" type="l" color="0x0066ff" encoding="csv">0.0,12.0
350.0,12.0
					</series>
					<series title="14 + bits[7]" type="l" color="0x3300ff" encoding="csv">0.0,14.0
350.0,14.0
					</series>
					<series title="bitsCovered" type="l" color="0xcc00ff" encoding="csv">0.0,0.0
0.0,1.0
21.48884116555564,1.0
21.48884116555564,2.0
43.419370179763064,2.0
43.419370179763064,3.0
63.419370179763064,3.0
63.419370179763064,4.0
83.64513209089637,4.0
83.64513209089637,5.0
103.64513209089637,5.0
103.64513209089637,6.0
123.64513209089637,6.0
123.64513209089637,7.0
146.39630878111348,7.0
146.39630878111348,8.0
166.39630878111348,8.0
166.39630878111348,9.0
187.9592922620941,9.0
187.9592922620941,10.0
209.99395743594505,10.0
209.99395743594505,11.0
234.01308378712426,11.0
234.01308378712426,12.0
256.5658743326976,12.0
256.5658743326976,13.0
278.7766543858275,13.0
278.7766543858275,14.0
301.9969100044731,14.0
301.9969100044731,15.0
321.99691000447297,15.0
321.99691000447297,16.0
344.13134875023025,16.0
344.13134875023025,17.0
350.0,17.0
					</series>
					<series title="16 + allCovered" type="l" color="0xff0099" encoding="csv">0.0,16.0
350.0,16.0
					</series>
					<comment/>
				</plot>
			</result>
		</query>
		<query>
			<formula>simulate [&lt;=1250;1] {bits[0], 2+bits[1], 4+bits[2], 6+bits[3], 10+bits[4], 12+bits[5], 14+bits[6], 16+bits[7], 20+bits[8], 22+bits[9], 24+bits[10], 26+bits[11], 28+bits[12], 32+difference, out_sum_all_acc, out_sum_all_approx}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=1500;1] {bits[0], 2+bits[1], 4+bits[2], 6+bits[3], 8+bits[4], 10+bits[5], 12+bits[6], 14+bits[7], 20+bits[8], 22+bits[9], 24+bits[10], 26+bits[11], bitsCovered, 20+allCovered, 30+mul2Atb.inSame, 40+mul2Atb.input, 30+mul2Atb.nsame, mul2Atb.rCover, 60+difference*10}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=2500;5] {100*((((100.0*(out_sum_all_acc-out_sum_all_approx))/(100.0*(out_sum_all_acc+1))))), out_sum_all_acc, out_sum_all_approx}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=2000;5] {40+difference, 50+10*err_magn_v, 100*err_magn_r, out_sum_all_acc, out_sum_all_approx, 80+out_sum_all_diff, mul2Atb.rCover, 100*((1+1.0*out_sum_all_acc)/(1+1.0*out_sum_all_approx))}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=4000;20] {out_sum_all_diff}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=400;5] {bits[0], 2+bits[1], 4+bits[2], 6+bits[3], 10+bits[4], 12+bits[5], 14+bits[6], 16+bits[7], 20+bits[8], 22+bits[9], 24+bits[10], 26+bits[11], 30+bits[14], 32+bits[15], 34+bits[16], 36+bits[13], 38+bits[12], 40+difference, 45+diffctrl, 50+outcnt}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>sup: err_magn_v
			</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=2500; 10] (max:err_magn_v)
			</formula>
			<comment/>
			<result outcome="success" type="quantity" value="≈ 0" timestamp="2024-02-28 12:16:48 +0100">
				<details>≈ 0</details>
				<plot title="Probability Density Distribution" xaxis="max: err_magn_v" yaxis="probability density">
					<series title="density" type="b(1.000000)" color="0x0000ff" encoding="csv">0.0,1.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">0.0,0.0
0.0,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=1
Runs: 10 in total, 10 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [0, 0]
Mean estimate of displayed sample: ≈ 0</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="max: err_magn_v" yaxis="probability">
					<series title="probability" type="b(1.000000)" color="0x0000ff" encoding="csv">0.0,1.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">0.0,0.0
0.0,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=1
Runs: 10 in total, 10 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [0, 0]
Mean estimate of displayed sample: ≈ 0</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="max: err_magn_v" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">0.0,0.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">0.0,0.0
0.0,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=1
Runs: 10 in total, 10 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [0, 0]
Mean estimate of displayed sample: ≈ 0</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="max: err_magn_v" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">0.0,0.30849710781876083
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">0.0,0.0
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">0.0,0.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">0.0,0.0
0.0,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=1
Runs: 10 in total, 10 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [0, 0]
Mean estimate of displayed sample: ≈ 0</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="max: err_magn_v" yaxis="count">
					<series title="count" type="b(1.000000)" color="0x0000ff" encoding="csv">0.0,10.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">0.0,0.0
0.0,10.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=1
Runs: 10 in total, 10 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [0, 0]
Mean estimate of displayed sample: ≈ 0</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>E[&lt;=2500; 10] (max:err_magn_r)
			</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=25000; 10] (max:out_sum_all_diff)
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=5000;200] {bitsCovered, 100*allCovered, mul2Atb.rCover}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>Pr[&lt;=50000] (&lt;&gt;allCovered)
			</formula>
			<comment/>
		</query>
	</queries>
</nta>

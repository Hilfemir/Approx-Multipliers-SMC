<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>/* Feel free to cite and/or read details to the model using:
  STRNADEL Josef. Statistical Model Checking of Approximate Circuits: Challenges and Opportunities. In: Proceedings of the 2020 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE). Grenoble: IEEE Computer Society, 2020, pp. 1574-1577. ISBN 978-3-9819263-4-7. Available from: https://ieeexplore.ieee.org/document/9116207 and https://www.fit.vut.cz/research/publication/12055/
 */
double rnd;

broadcast chan change[1000];
int outcnt=0;

const int NOPS = 7;
typedef int[0,NOPS-1] tOp;

const tOp OP_NOT = 0;
const tOp OP_DLY = 1;
const tOp OP_AND = 2;
const tOp OP_NAND = 3;
const tOp OP_OR = 4;
const tOp OP_NOR = 5;
const tOp OP_XOR = 6;

const int NCOM = 300;
tOp tbl_op[NCOM] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 6, 2, 6, 2, 6, 2, 6, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 6, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 2, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 2, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 2, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 2, 2, 2, 2, 2, 2, 2, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 6, 2, 2, 6, 4, 1};

int duration(tOp op){  
    int duration=0;
    if(op==OP_NOT) duration=3;
    if(op==OP_DLY) duration=10;
    if(op==OP_AND) duration=10;
    if(op==OP_NAND) duration=13;
    if(op==OP_OR) duration=10;
    if(op==OP_NOR) duration=13;
    if(op==OP_XOR) duration=20;
    return duration;
}

broadcast chan go, pwrUp;

const double COVERAGE_RATIO = 100.0;
const int DLY_ZERO = 0;

const int TBL_PWR2[31] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824};

broadcast chan update;
broadcast chan cmpDone;

const int MAX_BITS = 1024;
bool bits[MAX_BITS];
bool difference=false;
bool dif2=false;
int diffctrl=0;
int err_magn_v;    
double err_magn_r;  

int out_sum_all_acc;
int out_sum_all_approx;
int out_sum_all_diff;

int bitsCovered;
double inCoverage;

bool allCovered=false;

const int MAX_INT = 65536;

const int NIB_MUL2 = 16;
const int NOB_MUL2 = 16;
const int NTV_MUL2 = TBL_PWR2[NIB_MUL2]; 
const int DLY_MUL2 = 20;                 

/* ===------------------------  ------------------------==== */
int getMasked(int w, int offset, int[0,MAX_INT] data){ 
    int mask = (TBL_PWR2[w]-1);    
   return (data &amp; (mask &lt;&lt; offset)) &gt;&gt; offset;     
}    
bool getBit(int pos, int[0,MAX_INT] data){ return getMasked(1, pos, data); }

const int NIB_ANY = 16;
const int NOB_ANY = 16;
const int NTV_ANY = TBL_PWR2[NIB_ANY]; 
const int DLY_ANY = 20;                 
bool tbl_acc_any[TBL_PWR2[NIB_ANY]][NIB_ANY+NOB_ANY];
//
const int NFUN = 1;
typedef int[0,NFUN-1] tFun;
//-------
const tFun F_MUL = 0;
//
void fill_tbl_acc_any(int win, int wout, tFun f, int fdly){
    int[0,MAX_INT] i;
    int[0,MAX_INT] result;
    int j, k, op0, op1;
    for(i=0; i&lt;TBL_PWR2[win]; i++){    
        for(j=0; j&lt;win; j++){
            tbl_acc_any[i][j] = getBit(j,i);
        }
        if(f==F_MUL){
            op0 = getMasked(win/2, 0, i);
            op1 = getMasked(win/2, win/2, i);
            result = op0*op1;
        }
        else { result = 0; }
        for(k=0; k&lt;wout; k++){
            tbl_acc_any[i][win+(wout-k-1)] = getBit(k,result);
        }
    }
}

/* ===------------------------  ------------------------==== */
const int NPI = NIB_MUL2;    
const int NPO = NOB_MUL2;   
//
const int NTV = NTV_MUL2; 
const int DLY = DLY_MUL2;
//
const int PIxy[NPI] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
const int POx[NPO] = {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31};
//
const int POy[NPO] = {-1, 33, -1, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47};
/* ===------------------------  ------------------------==== */

const int MAX_INNER_NODES = 1000;
typedef struct {
    int dly;
    bool flag;
} sNode;
sNode nodes[MAX_INNER_NODES];

const int MAX_INNER_GATES = 1000;
typedef struct {
    bool active;
    int in0;
    int in1;
    int inAvail;
    int out0;
    int dly;
    int depth;
    bool flag;
} sGate;
sGate gates[MAX_INNER_GATES];

int approxCircNodes = 0;
int approxCircGates = 0;
int approxCircDly=0;
int approxCircDepth=0;


bool outEq(){
    bool same=true;
    int i;
    for(i=0; i&lt;NPO; i++){
        if((POx[i]&gt;=0) &amp;&amp; (POy[i]&gt;=0)){
            if(bits[POx[i]] != bits[POy[i]]){
                same = false;
            }
        }
    }
    return same;
}

void diff(){
    int res_acc=0, res_approx=0;
    int i;

    difference = !outEq();

     for(i=0; i&lt;=NPO-1; i++){                                       
        res_acc += bits[i+NPI]*TBL_PWR2[i];
        if(POy[i]&gt;=0) res_approx += bits[i+NPI+NPO]*TBL_PWR2[i];    
    }
    out_sum_all_acc += res_acc;
    out_sum_all_approx += res_approx;
    out_sum_all_diff = out_sum_all_acc - out_sum_all_approx;
    err_magn_v = res_acc - res_approx;
    if(res_acc!=0) err_magn_r = 1-((1.0*res_approx)/(1.0*res_acc));
}
</declaration>
	<template>
		<name>tmul2any</name>
		<parameter>const int &amp;PIxy[NPI], const int &amp;POx[NPO], bool &amp;ttbl[TBL_PWR2[NIB_ANY]][NIB_ANY+NOB_ANY], const int  dly</parameter>
		<declaration>
clock x;

int getIdx(int i){
    int idx=-1;

    if(i &lt; NPI) {
        idx = PIxy[i];
    }
    else {
        idx = POx[i-NPI];
    }

    return idx;
}


int bin2dec()
{
    int result=0, i;
    for(i=0; i&lt;NIB_MUL2; i++){
        result += bits[getIdx(i)]*TBL_PWR2[i];
    }

    return result;
}


int getOut(){
    int res, i;
    for(i=NIB_MUL2; i&lt;NIB_MUL2+NOB_MUL2; i++){
        res += bits[getIdx(i)]*TBL_PWR2[i-NIB_MUL2];
    }
    return res;    
}

void f(){
    if(POx[15]&gt;=0) bits[POx[15]]=ttbl[bin2dec()][16];
    if(POx[14]&gt;=0) bits[POx[14]]=ttbl[bin2dec()][17];
    if(POx[13]&gt;=0) bits[POx[13]]=ttbl[bin2dec()][18];
    if(POx[12]&gt;=0) bits[POx[12]]=ttbl[bin2dec()][19];
    if(POx[11]&gt;=0) bits[POx[11]]=ttbl[bin2dec()][20];
    if(POx[10]&gt;=0) bits[POx[10]]=ttbl[bin2dec()][21];
    if(POx[9]&gt;=0) bits[POx[9]]=ttbl[bin2dec()][22];
    if(POx[8]&gt;=0) bits[POx[8]]=ttbl[bin2dec()][23];
    if(POx[7]&gt;=0) bits[POx[7]]=ttbl[bin2dec()][24];
    if(POx[6]&gt;=0) bits[POx[6]]=ttbl[bin2dec()][25];
    if(POx[5]&gt;=0) bits[POx[5]]=ttbl[bin2dec()][26];
    if(POx[4]&gt;=0) bits[POx[4]]=ttbl[bin2dec()][27];
    if(POx[3]&gt;=0) bits[POx[3]]=ttbl[bin2dec()][28];
    if(POx[2]&gt;=0) bits[POx[2]]=ttbl[bin2dec()][29];
    if(POx[1]&gt;=0) bits[POx[1]]=ttbl[bin2dec()][30];
    if(POx[0]&gt;=0) bits[POx[0]]=ttbl[bin2dec()][31];

    diffctrl++;
}

void inits(){
    fill_tbl_acc_any(NIB_ANY, NOB_ANY, F_MUL, dly);
}

</declaration>
		<location id="id0" x="-170" y="0">
		</location>
		<location id="id1" x="0" y="0">
			<label kind="invariant" x="-25" y="17">x&lt;=dly</label>
		</location>
		<location id="id2" x="-374" y="0">
			<committed/>
		</location>
		<init ref="id2"/>
		<transition id="id3">
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="assignment" x="-297" y="0">inits()</label>
		</transition>
		<transition id="id4">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="guard" x="-152" y="-136">x==dly</label>
			<label kind="assignment" x="17" y="-59">f()</label>
			<nail x="0" y="-102"/>
			<nail x="-170" y="-102"/>
		</transition>
		<transition id="id5">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-110" y="-25">update?</label>
			<label kind="assignment" x="-93" y="0">x=0</label>
		</transition>
	</template>
	<template>
		<name>tmul2_tb_exhaust</name>
		<parameter>const int &amp;PIxy[NPI], const int dly, const double covratio</parameter>
		<declaration>
clock x;
clock tcover;
int input=0;
int nsame=0, inSame=0;
double rCover;

bool inCoverSet[NTV];

int covered()
{
    int cnt=0;

    for(i: int[0,NTV-1])
    {
        if(inCoverSet[i]) {
            cnt++;
        }
    }

    bitsCovered=cnt;

    return cnt;
}

int bin2dec()
{
    int result=0, i;
    for(i=0; i&lt;NPI; i++){
        result += bits[i]*TBL_PWR2[i];
    }

    return result;
}


bool inCovered()
{
  return forall (i : int[0,NTV-1]) inCoverSet[i];    
}



void f(){
    bits[PIxy[0]] = getBit(0, input);
    bits[PIxy[1]] = getBit(1, input);
    bits[PIxy[2]] = getBit(2, input);
    bits[PIxy[3]] = getBit(3, input);
    bits[PIxy[4]] = getBit(4, input);
    bits[PIxy[5]] = getBit(5, input);
    bits[PIxy[6]] = getBit(6, input);
    bits[PIxy[7]] = getBit(7, input);

    if(inCoverSet[input]) { inSame = -1*input; nsame++; }
    else inSame = input;
    inCoverSet[input] = true;
    input = (input+1) % NTV;
    covered();

    rCover = 100.0*bitsCovered / NTV; 
}

void inits(){
    int i;
    for(i:int[0,MAX_INNER_NODES-1]){ nodes[i].flag=false; }
    for(i:int[0,NPI-1]){
        if(exists(j:int[0,NPI-1]) PIxy[j]==i){ 
            nodes[i].flag=true;    
            nodes[i].dly=0;        
        }
        approxCircNodes++;
    }
    for(i=0; i&lt;approxCircGates; i++) gates[i].flag=false;    
    while(exists(i:int[0,MAX_INNER_GATES-1]) (gates[i].flag==false &amp;&amp; i&lt;approxCircGates)){
        approxCircDepth++;
        for(i=0; i&lt;approxCircGates; i++) {
            if(!gates[i].flag &amp;&amp; nodes[gates[i].in0].flag &amp;&amp; nodes[gates[i].in1].flag){  
                nodes[gates[i].out0].dly = (nodes[gates[i].in0].dly&gt;nodes[gates[i].in1].dly?nodes[gates[i].in0].dly:nodes[gates[i].in1].dly) + duration(tbl_op[i]);
                nodes[gates[i].out0].flag=true;
                approxCircNodes++;
                if(nodes[gates[i].out0].dly&lt;approxCircDly){ approxCircDly=nodes[gates[i].out0].dly; }

                gates[i].flag=true;   
            }  
        }
    }
}
</declaration>
		<location id="id6" x="-136" y="0">
			<name x="-153" y="8">apply</name>
			<committed/>
		</location>
		<location id="id7" x="-374" y="0">
			<name x="-382" y="8">get</name>
			<committed/>
		</location>
		<location id="id8" x="34" y="0">
			<name x="17" y="8">done</name>
			<label kind="invariant" x="0" y="-34">tcover'==0</label>
		</location>
		<location id="id9" x="-246" y="-102">
			<name x="-255" y="-136">wait</name>
		</location>
		<location id="id10" x="-510" y="0">
			<urgent/>
		</location>
		<init ref="id10"/>
		<transition id="id11">
			<source ref="id10"/>
			<target ref="id7"/>
			<label kind="assignment" x="-459" y="0">inits()</label>
		</transition>
		<transition id="id12">
			<source ref="id6"/>
			<target ref="id9"/>
			<label kind="guard" x="-221" y="-93">!inCovered()</label>
			<nail x="-136" y="-102"/>
		</transition>
		<transition id="id13">
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="guard" x="-93" y="-25">inCovered()</label>
			<label kind="assignment" x="-110" y="0">allCovered=true,
x=0</label>
		</transition>
		<transition id="id14">
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-289" y="-25">update!</label>
			<label kind="assignment" x="-280" y="0">f(), x=0</label>
		</transition>
		<transition id="id15">
			<source ref="id9"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-365" y="-93">cmpDone?</label>
			<nail x="-374" y="-102"/>
		</transition>
	</template>
	<template>
		<name>tmul2_tb_nondet</name>
		<parameter>const int range_min, const int range_max, const int dly, const double covratio</parameter>
		<declaration>clock x;
clock tcover;
int input=0;
int nsame=0, inSame=0;
double rCover;
int idx=0;

bool inCoverSet[NTV];

int covered()
{
    int cnt=0;

    for(i: int[0,NTV-1])
    {
        if(inCoverSet[i]) {
            cnt++;
        }
    }

    bitsCovered=cnt;

    return cnt;
}

int bin2dec()
{
    int result=0, i;
    for(i=0; i&lt;NPI; i++){
        result += bits[i]*TBL_PWR2[i];
    }

    return result;
}


bool inCovered()
{
  return forall (i : int[0,NTV-1]) inCoverSet[i];    
}

void f(int i){
    input = bin2dec();
   if(inCoverSet[input]) { inSame = -1*input; nsame++; }
  else inSame = input;
   inCoverSet[bin2dec()] = true;
    covered();

    rCover = 100.0*bitsCovered / NTV; 

    inCoverage = 0.0;
}

void inits(){
    int i;
    for(i:int[0,MAX_INNER_NODES-1]){ nodes[i].flag=false; }
    for(i:int[0,NPI-1]){
        if(exists(j:int[0,NPI-1]) PIxy[j]==i){ 
            nodes[i].flag=true;
            nodes[i].dly=0;      
        }
        approxCircNodes++;
    }
    for(i=0; i&lt;approxCircGates; i++) gates[i].flag=false;    
    while(exists(i:int[0,MAX_INNER_GATES-1]) (gates[i].flag==false &amp;&amp; i&lt;approxCircGates)){
        approxCircDepth++;
        for(i=0; i&lt;approxCircGates; i++) {
            if(!gates[i].flag &amp;&amp; nodes[gates[i].in0].flag &amp;&amp; nodes[gates[i].in1].flag){  
                nodes[gates[i].out0].dly = (nodes[gates[i].in0].dly&gt;nodes[gates[i].in1].dly?nodes[gates[i].in0].dly:nodes[gates[i].in1].dly) + duration(tbl_op[i]);
                nodes[gates[i].out0].flag=true;
                approxCircNodes++;
                if(nodes[gates[i].out0].dly&gt;approxCircDly){ approxCircDly=nodes[gates[i].out0].dly; }

                gates[i].flag=true;
            }  
        }
    }
}</declaration>
		<location id="id16" x="-119" y="-102">
			<name x="-129" y="-136">wait</name>
		</location>
		<location id="id17" x="-246" y="0">
			<name x="-255" y="8">get</name>
			<committed/>
		</location>
		<location id="id18" x="170" y="0">
			<name x="153" y="8">done</name>
			<label kind="invariant" x="136" y="-34">tcover'==0</label>
		</location>
		<location id="id19" x="0" y="0">
			<name x="-17" y="8">apply</name>
			<committed/>
		</location>
		<location id="id20" x="-246" y="-102">
			<committed/>
		</location>
		<location id="id21" x="-374" y="0">
			<urgent/>
		</location>
		<init ref="id21"/>
		<transition id="id22">
			<source ref="id21"/>
			<target ref="id17"/>
			<label kind="assignment" x="-331" y="0">inits()</label>
		</transition>
		<transition id="id23">
			<source ref="id20"/>
			<target ref="id17"/>
			<label kind="select" x="-238" y="-68">i: int[range_min, range_max]</label>
			<label kind="assignment" x="-238" y="-51">bits[i] ^= 1, idx=i</label>
		</transition>
		<transition id="id24">
			<source ref="id16"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-212" y="-102">cmpDone?</label>
		</transition>
		<transition id="id25">
			<source ref="id19"/>
			<target ref="id16"/>
			<label kind="guard" x="-93" y="-93">!inCovered()</label>
			<nail x="0" y="-102"/>
		</transition>
		<transition id="id26">
			<source ref="id17"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-153" y="-25">update!</label>
			<label kind="assignment" x="-144" y="0">f(idx)</label>
		</transition>
		<transition id="id27">
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="guard" x="42" y="-25">inCovered()</label>
			<label kind="assignment" x="34" y="0">allCovered=true</label>
		</transition>
	</template>
	<template>
		<name>tmul2_tb_random</name>
		<parameter>const int dly, const double covratio</parameter>
		<declaration>clock x;
clock tcover;
int input=0;
int nsame=0, inSame=0;
double rCover;
int idx=0;

bool inCoverSet[NTV];

int covered()
{
    int cnt=0;

    for(i: int[0,NTV-1])
    {
        if(inCoverSet[i]) {
            cnt++;
        }
    }

    bitsCovered=cnt;

    return cnt;
}

int bin2dec()
{
    int result=0, i;
    for(i=0; i&lt;NPI; i++){
        result += bits[i]*TBL_PWR2[i];
    }

    return result;
}


bool inCovered()
{
  return forall (i : int[0,NTV-1]) inCoverSet[i];    
}

void f(int i){
    int j;
    int imax = fint(exp2(NPI));

//    rnd = random(100);
//    rnd = random_arcsine(-10,10);
//    rnd = random_beta(0.1,5);
//    rnd = random_gamma(0.5,5);
//    rnd = random_normal(10,1);
//    rnd = random_poisson(1.0);
//    rnd = random_weibull(0.5,5);
//    rnd = random_tri(0,10,100);

    j=fint(random(NPI));                   // pro (NPI) je out 0...NPI-1
 //   j=fint(random_normal(NPI/2.0,0.5));    // pro (NPI/2.0, 0.5) je out NPI/2 +- 0.5
 //   j=fint(random_poisson(1.0));           // pro (1.0) je out 1.0 +- 
//    j=fint(random_arcsine(0.0, NPI-1));    // pro (0.0, NPI-1) je out mezi 0...NPI-1 (aka random())
  //  j=fint(random_tri(0.0, 0.5, NPI-1));    // pro (0.0, 0.5, NPI-1) je out mezi 0...NPI-1 (aka random()), se stredem u 0.5
  //  j = fint(random_weibull(10, 3.0));    // pro (10.0, 3.0) je out mezi 0...3 (aka random()), se stredem vys (pro 10)
  //  j = fint(random_gamma(1.0,0.5));    // pro (1.0, 0.5) je out mezi 0...5 (aka random()), se stredem niz (kolem 1.0)
    if(j &lt; 0) j=0;
    if(j &gt; (NPI-1)) j=NPI-1;
    bits[j] ^= 1;

   if(inCoverSet[input]) { inSame = -1*input; nsame++; }
   else inSame = input;
   inCoverSet[bin2dec()] = true;
    covered();

    rCover = 100.0*bitsCovered / NTV; 

    inCoverage = 0.0;
}

void inits(){
    int i;
    for(i:int[0,MAX_INNER_NODES-1]){ nodes[i].flag=false; }
    for(i:int[0,NPI-1]){
        if(exists(j:int[0,NPI-1]) PIxy[j]==i){ 
            nodes[i].flag=true;    
            nodes[i].dly=0;        
        }
        approxCircNodes++;
    }
    for(i=0; i&lt;approxCircGates; i++) gates[i].flag=false;
    while(exists(i:int[0,MAX_INNER_GATES-1]) (gates[i].flag==false &amp;&amp; i&lt;approxCircGates)){
        approxCircDepth++;
        for(i=0; i&lt;approxCircGates; i++) {
            if(!gates[i].flag &amp;&amp; nodes[gates[i].in0].flag &amp;&amp; nodes[gates[i].in1].flag){  
                nodes[gates[i].out0].dly = (nodes[gates[i].in0].dly&gt;nodes[gates[i].in1].dly?nodes[gates[i].in0].dly:nodes[gates[i].in1].dly) + duration(tbl_op[i]);
                nodes[gates[i].out0].flag=true;
                approxCircNodes++;
                if(nodes[gates[i].out0].dly&gt;approxCircDly){ approxCircDly=nodes[gates[i].out0].dly; }

                gates[i].flag=true; 
            }  
        }
    }
}</declaration>
		<location id="id28" x="-119" y="-102">
			<name x="-129" y="-136">wait</name>
		</location>
		<location id="id29" x="-246" y="0">
			<name x="-255" y="8">get</name>
			<committed/>
		</location>
		<location id="id30" x="170" y="0">
			<name x="153" y="8">done</name>
			<label kind="invariant" x="136" y="-34">tcover'==0</label>
		</location>
		<location id="id31" x="0" y="0">
			<name x="-17" y="8">apply</name>
			<committed/>
		</location>
		<location id="id32" x="-246" y="-102">
			<committed/>
		</location>
		<location id="id33" x="-374" y="0">
			<urgent/>
		</location>
		<init ref="id33"/>
		<transition id="id34">
			<source ref="id33"/>
			<target ref="id29"/>
			<label kind="assignment" x="-331" y="0">inits()</label>
		</transition>
		<transition id="id35">
			<source ref="id32"/>
			<target ref="id29"/>
		</transition>
		<transition id="id36">
			<source ref="id28"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="-212" y="-102">cmpDone?</label>
		</transition>
		<transition id="id37">
			<source ref="id31"/>
			<target ref="id28"/>
			<label kind="guard" x="-93" y="-93">!inCovered()</label>
			<nail x="0" y="-102"/>
		</transition>
		<transition id="id38">
			<source ref="id29"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="-153" y="-25">update!</label>
			<label kind="assignment" x="-144" y="0">f(idx)</label>
		</transition>
		<transition id="id39">
			<source ref="id31"/>
			<target ref="id30"/>
			<label kind="guard" x="42" y="-25">inCovered()</label>
			<label kind="assignment" x="34" y="0">allCovered=true</label>
		</transition>
	</template>
	<template>
		<name>syncPrimary</name>
		<declaration>int idx;</declaration>
		<location id="id40" x="-748" y="-306">
		</location>
		<location id="id41" x="-646" y="-306">
			<committed/>
		</location>
		<location id="id42" x="-510" y="-306">
			<committed/>
		</location>
		<init ref="id40"/>
		<transition id="id43">
			<source ref="id42"/>
			<target ref="id40"/>
			<label kind="guard" x="-646" y="-399">idx&gt;=NPI</label>
			<nail x="-510" y="-374"/>
			<nail x="-748" y="-374"/>
		</transition>
		<transition id="id44">
			<source ref="id42"/>
			<target ref="id41"/>
			<label kind="guard" x="-595" y="-323">idx&lt;NPI</label>
			<nail x="-578" y="-272"/>
		</transition>
		<transition id="id45">
			<source ref="id41"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-612" y="-340">change[idx]!</label>
			<label kind="assignment" x="-629" y="-280">idx++</label>
		</transition>
		<transition id="id46">
			<source ref="id40"/>
			<target ref="id41"/>
			<label kind="synchronisation" x="-730" y="-323">update?</label>
			<label kind="assignment" x="-714" y="-306">idx=0</label>
		</transition>
	</template>
	<template>
		<name>eval_diff</name>
		<parameter>const int dly</parameter>
		<declaration>clock x;</declaration>
		<location id="id47" x="-238" y="0">
			<label kind="invariant" x="-297" y="-8">x&lt;=dly</label>
		</location>
		<location id="id48" x="-102" y="0">
			<committed/>
		</location>
		<init ref="id47"/>
		<transition id="id49">
			<source ref="id48"/>
			<target ref="id47"/>
			<label kind="synchronisation" x="-178" y="51">cmpDone!</label>
			<label kind="assignment" x="-246" y="110">outcnt=0, diffctrl=0, x=0</label>
			<nail x="-102" y="110"/>
			<nail x="-238" y="110"/>
		</transition>
		<transition id="id50">
			<source ref="id47"/>
			<target ref="id47"/>
			<label kind="guard" x="-331" y="-93">diffctrl&lt;2
&amp;&amp; x==dly</label>
			<label kind="assignment" x="-289" y="-42">x=0</label>
			<nail x="-263" y="-76"/>
			<nail x="-229" y="-76"/>
		</transition>
		<transition id="id51">
			<source ref="id47"/>
			<target ref="id48"/>
			<label kind="guard" x="-204" y="0">diffctrl==2</label>
			<label kind="assignment" x="-212" y="-68">err_magn_v=0,
err_magn_r=0.0,
diff()</label>
		</transition>
	</template>
	<template>
		<name>gate2</name>
		<parameter>const int id, const int a0, const int a1, const int y0, broadcast chan &amp;cin0, broadcast chan &amp;cin1, broadcast chan &amp;cout0</parameter>
		<declaration>clock x;

void inits(){
    int i;

    // collect info about the approx.circuit topology 
    gates[id].active = true;
    gates[id].in0 = a0; 
    gates[id].in1 = a1; 
    gates[id].inAvail = 0; 
    gates[id].out0 = y0; 
    gates[id].dly = duration(tbl_op[id]);
    gates[id].depth = -1;
    gates[id].flag = false;

    approxCircGates++;    
}

void outGen(tOp op){
 //   outSync(y0);

    if(op == OP_AND){
        bits[y0] = bits[a0] &amp; bits[a1];        
    }
    else if(op == OP_NAND){
        bits[y0] = not (bits[a0] &amp; bits[a1]);        
    }
    else if(op == OP_OR){
        bits[y0] = bits[a0] | bits[a1];        
    }
    else if(op == OP_NOR){
        bits[y0] = not (bits[a0] | bits[a1]);        
    }
    else if(op == OP_XOR){
        bits[y0] = (bits[a0] != bits[a1]);        
    }
    else {    // unsupported operation
    }

    if(id==2){ 
        if(diffctrl&lt;2) diffctrl++;
    }  
}</declaration>
		<location id="id52" x="-170" y="0">
		</location>
		<location id="id53" x="0" y="0">
			<label kind="invariant" x="-17" y="17">x&lt;=duration(tbl_op[id])</label>
		</location>
		<location id="id54" x="-272" y="0">
			<committed/>
		</location>
		<init ref="id54"/>
		<transition id="id55">
			<source ref="id54"/>
			<target ref="id52"/>
			<label kind="assignment" x="-238" y="0">inits()</label>
		</transition>
		<transition id="id56">
			<source ref="id52"/>
			<target ref="id53"/>
			<label kind="synchronisation" x="-144" y="0">cin1?</label>
			<label kind="assignment" x="-76" y="0">x=0</label>
			<nail x="-85" y="0"/>
		</transition>
		<transition id="id57">
			<source ref="id53"/>
			<target ref="id52"/>
			<label kind="guard" x="-110" y="-127">x==duration(tbl_op[id])</label>
			<label kind="synchronisation" x="8" y="-68">cout0!</label>
			<label kind="assignment" x="-144" y="-102">outGen(tbl_op[id])</label>
			<nail x="0" y="-102"/>
			<nail x="-170" y="-102"/>
		</transition>
		<transition id="id58">
			<source ref="id52"/>
			<target ref="id53"/>
			<label kind="synchronisation" x="-136" y="-42">cin0?</label>
			<label kind="assignment" x="-59" y="-42">x=0</label>
			<nail x="-85" y="-34"/>
		</transition>
	</template>
	<system>
// Place template instantiations here.

synPri = syncPrimary();
mul2A = tmul2any(PIxy, POx, tbl_acc_any, DLY_MUL2);

mul2Atb = tmul2_tb_exhaust(PIxy, DLY_MUL2, COVERAGE_RATIO);
//mul2Atb = tmul2_tb_nondet(PIxy[0], PIxy[7], DLY_MUL2, COVERAGE_RATIO);
//mul2Atb = tmul2_tb_random(PIxy, DLY_MUL2, COVERAGE_RATIO);

ediff = eval_diff(5);

//gates
g19 = gate2(0, PIxy[11], PIxy[0], 19, change[11], change[0], change[19]);
g20 = gate2(1, PIxy[12], PIxy[0], 20, change[12], change[0], change[20]);
g21 = gate2(2, PIxy[13], PIxy[0], 21, change[13], change[0], change[21]);
g22 = gate2(3, PIxy[14], PIxy[0], 22, change[14], change[0], change[22]);
g23 = gate2(4, PIxy[15], PIxy[0], 23, change[15], change[0], change[23]);
g26 = gate2(5, PIxy[10], PIxy[1], 26, change[10], change[1], change[26]);
g27 = gate2(6, PIxy[11], PIxy[1], 27, change[11], change[1], change[27]);
g28 = gate2(7, PIxy[12], PIxy[1], 28, change[12], change[1], change[28]);
g29 = gate2(8, PIxy[13], PIxy[1], 29, change[13], change[1], change[29]);
g30 = gate2(9, PIxy[14], PIxy[1], 30, change[14], change[1], change[30]);
g31 = gate2(10, PIxy[15], PIxy[1], 31, change[15], change[1], change[31]);
g35 = gate2(11, PIxy[14], 31, 35, change[14], change[31], change[35]);
g36 = gate2(12, 19, 26, 36, change[19], change[26], change[36]);
g37 = gate2(13, 19, 26, 37, change[19], change[26], change[37]);
g38 = gate2(14, 20, 27, 38, change[20], change[27], change[38]);
g39 = gate2(15, 20, 27, 39, change[20], change[27], change[39]);
g40 = gate2(16, 21, 28, 40, change[21], change[28], change[40]);
g41 = gate2(17, 21, 28, 41, change[21], change[28], change[41]);
g42 = gate2(18, 22, 29, 42, change[22], change[29], change[42]);
g43 = gate2(19, 22, 29, 43, change[22], change[29], change[43]);
g44 = gate2(20, 23, 30, 44, change[23], change[30], change[44]);
g45 = gate2(21, PIxy[0], 35, 45, change[0], change[35], change[45]);
g47 = gate2(22, PIxy[9], PIxy[2], 47, change[9], change[2], change[47]);
g48 = gate2(23, PIxy[10], PIxy[2], 48, change[10], change[2], change[48]);
g49 = gate2(24, PIxy[11], PIxy[2], 49, change[11], change[2], change[49]);
g50 = gate2(25, PIxy[12], PIxy[2], 50, change[12], change[2], change[50]);
g51 = gate2(26, PIxy[13], PIxy[2], 51, change[13], change[2], change[51]);
g52 = gate2(27, PIxy[14], PIxy[2], 52, change[14], change[2], change[52]);
g53 = gate2(28, PIxy[15], PIxy[2], 53, change[15], change[2], change[53]);
g59 = gate2(29, 36, 47, 59, change[36], change[47], change[59]);
g60 = gate2(30, 36, 47, 60, change[36], change[47], change[60]);
g64 = gate2(31, 38, 48, 64, change[38], change[48], change[64]);
g65 = gate2(32, 38, 48, 65, change[38], change[48], change[65]);
g66 = gate2(33, 64, 37, 66, change[64], change[37], change[66]);
g67 = gate2(34, 64, 37, 67, change[64], change[37], change[67]);
g68 = gate2(35, 65, 66, 68, change[65], change[66], change[68]);
g69 = gate2(36, 40, 49, 69, change[40], change[49], change[69]);
g70 = gate2(37, 40, 49, 70, change[40], change[49], change[70]);
g71 = gate2(38, 69, 39, 71, change[69], change[39], change[71]);
g72 = gate2(39, 69, 39, 72, change[69], change[39], change[72]);
g73 = gate2(40, 70, 71, 73, change[70], change[71], change[73]);
g74 = gate2(41, 42, 50, 74, change[42], change[50], change[74]);
g75 = gate2(42, 42, 50, 75, change[42], change[50], change[75]);
g76 = gate2(43, 74, 41, 76, change[74], change[41], change[76]);
g77 = gate2(44, 74, 41, 77, change[74], change[41], change[77]);
g78 = gate2(45, 75, 76, 78, change[75], change[76], change[78]);
g79 = gate2(46, 44, 51, 79, change[44], change[51], change[79]);
g80 = gate2(47, 44, 51, 80, change[44], change[51], change[80]);
g81 = gate2(48, 79, 43, 81, change[79], change[43], change[81]);
g82 = gate2(49, 79, 43, 82, change[79], change[43], change[82]);
g83 = gate2(50, 80, 81, 83, change[80], change[81], change[83]);
g84 = gate2(51, 31, 52, 84, change[31], change[52], change[84]);
g85 = gate2(52, 35, 52, 85, change[35], change[52], change[85]);
g87 = gate2(53, 84, 45, 87, change[84], change[45], change[87]);
g88 = gate2(54, 85, 45, 88, change[85], change[45], change[88]);
g89 = gate2(55, PIxy[8], PIxy[3], 89, change[8], change[3], change[89]);
g90 = gate2(56, PIxy[9], PIxy[3], 90, change[9], change[3], change[90]);
g91 = gate2(57, PIxy[10], PIxy[3], 91, change[10], change[3], change[91]);
g92 = gate2(58, PIxy[11], PIxy[3], 92, change[11], change[3], change[92]);
g93 = gate2(59, PIxy[12], PIxy[3], 93, change[12], change[3], change[93]);
g94 = gate2(60, PIxy[13], PIxy[3], 94, change[13], change[3], change[94]);
g95 = gate2(61, PIxy[14], PIxy[3], 95, change[14], change[3], change[95]);
g96 = gate2(62, PIxy[15], PIxy[3], 96, change[15], change[3], change[96]);
g97 = gate2(63, 59, 89, POy[1], change[59], change[89], change[97]);
g98 = gate2(64, 59, 89, 98, change[59], change[89], change[98]);
g102 = gate2(65, 67, 90, 102, change[67], change[90], change[102]);
g103 = gate2(66, 67, 90, 103, change[67], change[90], change[103]);
g104 = gate2(67, 102, 60, 104, change[102], change[60], change[104]);
g105 = gate2(68, 102, 60, 105, change[102], change[60], change[105]);
g106 = gate2(69, 103, 104, 106, change[103], change[104], change[106]);
g107 = gate2(70, 72, 91, 107, change[72], change[91], change[107]);
g108 = gate2(71, 72, 91, 108, change[72], change[91], change[108]);
g109 = gate2(72, 107, 68, 109, change[107], change[68], change[109]);
g110 = gate2(73, 107, 68, 110, change[107], change[68], change[110]);
g111 = gate2(74, 108, 109, 111, change[108], change[109], change[111]);
g112 = gate2(75, 77, 92, 112, change[77], change[92], change[112]);
g113 = gate2(76, 77, 92, 113, change[77], change[92], change[113]);
g114 = gate2(77, 112, 73, 114, change[112], change[73], change[114]);
g115 = gate2(78, 112, 73, 115, change[112], change[73], change[115]);
g116 = gate2(79, 113, 114, 116, change[113], change[114], change[116]);
g117 = gate2(80, 82, 93, 117, change[82], change[93], change[117]);
g118 = gate2(81, 82, 93, 118, change[82], change[93], change[118]);
g119 = gate2(82, 117, 78, 119, change[117], change[78], change[119]);
g120 = gate2(83, 117, 78, 120, change[117], change[78], change[120]);
g121 = gate2(84, 118, 119, 121, change[118], change[119], change[121]);
g122 = gate2(85, 87, 94, 122, change[87], change[94], change[122]);
g123 = gate2(86, 87, 94, 123, change[87], change[94], change[123]);
g124 = gate2(87, 122, 83, 124, change[122], change[83], change[124]);
g125 = gate2(88, 122, 83, 125, change[122], change[83], change[125]);
g126 = gate2(89, 123, 124, 126, change[123], change[124], change[126]);
g127 = gate2(90, 53, 95, 127, change[53], change[95], change[127]);
g128 = gate2(91, 53, 95, 128, change[53], change[95], change[128]);
g129 = gate2(92, 127, 88, 129, change[127], change[88], change[129]);
g130 = gate2(93, 127, 88, 130, change[127], change[88], change[130]);
g131 = gate2(94, 128, 129, 131, change[128], change[129], change[131]);
g132 = gate2(95, PIxy[8], PIxy[4], 132, change[8], change[4], change[132]);
g133 = gate2(96, PIxy[9], PIxy[4], 133, change[9], change[4], change[133]);
g134 = gate2(97, PIxy[10], PIxy[4], 134, change[10], change[4], change[134]);
g135 = gate2(98, PIxy[11], PIxy[4], 135, change[11], change[4], change[135]);
g136 = gate2(99, PIxy[12], PIxy[4], 136, change[12], change[4], change[136]);
g137 = gate2(100, PIxy[13], PIxy[4], 137, change[13], change[4], change[137]);
g138 = gate2(101, PIxy[14], PIxy[4], 138, change[14], change[4], change[138]);
g139 = gate2(102, PIxy[15], PIxy[4], 139, change[15], change[4], change[139]);
g140 = gate2(103, 105, 132, 140, change[105], change[132], change[140]);
g141 = gate2(104, 105, 132, 141, change[105], change[132], change[141]);
g142 = gate2(105, 140, 98, 142, change[140], change[98], change[142]);
g143 = gate2(106, 140, 98, POy[4], change[140], change[98], change[143]);
g144 = gate2(107, 141, 142, 144, change[141], change[142], change[144]);
g145 = gate2(108, 110, 133, 145, change[110], change[133], change[145]);
g146 = gate2(109, 110, 133, 146, change[110], change[133], change[146]);
g147 = gate2(110, 145, 106, 147, change[145], change[106], change[147]);
g148 = gate2(111, 145, 106, 148, change[145], change[106], change[148]);
g149 = gate2(112, 146, 147, 149, change[146], change[147], change[149]);
g150 = gate2(113, 115, 134, 150, change[115], change[134], change[150]);
g151 = gate2(114, 115, 134, 151, change[115], change[134], change[151]);
g152 = gate2(115, 150, 111, 152, change[150], change[111], change[152]);
g153 = gate2(116, 150, 111, 153, change[150], change[111], change[153]);
g154 = gate2(117, 151, 152, 154, change[151], change[152], change[154]);
g155 = gate2(118, 120, 135, 155, change[120], change[135], change[155]);
g156 = gate2(119, 120, 135, 156, change[120], change[135], change[156]);
g157 = gate2(120, 155, 116, 157, change[155], change[116], change[157]);
g158 = gate2(121, 155, 116, 158, change[155], change[116], change[158]);
g159 = gate2(122, 156, 157, 159, change[156], change[157], change[159]);
g160 = gate2(123, 125, 136, 160, change[125], change[136], change[160]);
g161 = gate2(124, 125, 136, 161, change[125], change[136], change[161]);
g162 = gate2(125, 160, 121, 162, change[160], change[121], change[162]);
g163 = gate2(126, 160, 121, 163, change[160], change[121], change[163]);
g164 = gate2(127, 161, 162, 164, change[161], change[162], change[164]);
g165 = gate2(128, 130, 137, 165, change[130], change[137], change[165]);
g166 = gate2(129, 130, 137, 166, change[130], change[137], change[166]);
g167 = gate2(130, 165, 126, 167, change[165], change[126], change[167]);
g168 = gate2(131, 165, 126, 168, change[165], change[126], change[168]);
g169 = gate2(132, 166, 167, 169, change[166], change[167], change[169]);
g170 = gate2(133, 96, 138, 170, change[96], change[138], change[170]);
g171 = gate2(134, 96, 138, 171, change[96], change[138], change[171]);
g172 = gate2(135, 170, 131, 172, change[170], change[131], change[172]);
g173 = gate2(136, 170, 131, 173, change[170], change[131], change[173]);
g174 = gate2(137, 171, 172, 174, change[171], change[172], change[174]);
g175 = gate2(138, PIxy[8], PIxy[5], 175, change[8], change[5], change[175]);
g176 = gate2(139, PIxy[9], PIxy[5], 176, change[9], change[5], change[176]);
g177 = gate2(140, PIxy[10], PIxy[5], 177, change[10], change[5], change[177]);
g178 = gate2(141, PIxy[11], PIxy[5], 178, change[11], change[5], change[178]);
g179 = gate2(142, PIxy[12], PIxy[5], 179, change[12], change[5], change[179]);
g180 = gate2(143, PIxy[13], PIxy[5], 180, change[13], change[5], change[180]);
g181 = gate2(144, PIxy[14], PIxy[5], 181, change[14], change[5], change[181]);
g182 = gate2(145, PIxy[15], PIxy[5], 182, change[15], change[5], change[182]);
g183 = gate2(146, 148, 175, 183, change[148], change[175], change[183]);
g184 = gate2(147, 148, 175, 184, change[148], change[175], change[184]);
g185 = gate2(148, 183, 144, 185, change[183], change[144], change[185]);
g186 = gate2(149, 183, 144, POy[5], change[183], change[144], change[186]);
g187 = gate2(150, 184, 185, 187, change[184], change[185], change[187]);
g188 = gate2(151, 153, 176, 188, change[153], change[176], change[188]);
g189 = gate2(152, 153, 176, 189, change[153], change[176], change[189]);
g190 = gate2(153, 188, 149, 190, change[188], change[149], change[190]);
g191 = gate2(154, 188, 149, 191, change[188], change[149], change[191]);
g192 = gate2(155, 189, 190, 192, change[189], change[190], change[192]);
g193 = gate2(156, 158, 177, 193, change[158], change[177], change[193]);
g194 = gate2(157, 158, 177, 194, change[158], change[177], change[194]);
g195 = gate2(158, 193, 154, 195, change[193], change[154], change[195]);
g196 = gate2(159, 193, 154, 196, change[193], change[154], change[196]);
g197 = gate2(160, 194, 195, 197, change[194], change[195], change[197]);
g198 = gate2(161, 163, 178, 198, change[163], change[178], change[198]);
g199 = gate2(162, 163, 178, 199, change[163], change[178], change[199]);
g200 = gate2(163, 198, 159, 200, change[198], change[159], change[200]);
g201 = gate2(164, 198, 159, 201, change[198], change[159], change[201]);
g202 = gate2(165, 199, 200, 202, change[199], change[200], change[202]);
g203 = gate2(166, 168, 179, 203, change[168], change[179], change[203]);
g204 = gate2(167, 168, 179, 204, change[168], change[179], change[204]);
g205 = gate2(168, 203, 164, 205, change[203], change[164], change[205]);
g206 = gate2(169, 203, 164, 206, change[203], change[164], change[206]);
g207 = gate2(170, 204, 205, 207, change[204], change[205], change[207]);
g208 = gate2(171, 173, 180, 208, change[173], change[180], change[208]);
g209 = gate2(172, 173, 180, 209, change[173], change[180], change[209]);
g210 = gate2(173, 208, 169, 210, change[208], change[169], change[210]);
g211 = gate2(174, 208, 169, 211, change[208], change[169], change[211]);
g212 = gate2(175, 209, 210, 212, change[209], change[210], change[212]);
g213 = gate2(176, 139, 181, 213, change[139], change[181], change[213]);
g214 = gate2(177, 139, 181, 214, change[139], change[181], change[214]);
g215 = gate2(178, 213, 174, 215, change[213], change[174], change[215]);
g216 = gate2(179, 213, 174, 216, change[213], change[174], change[216]);
g217 = gate2(180, 214, 215, 217, change[214], change[215], change[217]);
g218 = gate2(181, PIxy[8], PIxy[6], 218, change[8], change[6], change[218]);
g219 = gate2(182, PIxy[9], PIxy[6], 219, change[9], change[6], change[219]);
g220 = gate2(183, PIxy[10], PIxy[6], 220, change[10], change[6], change[220]);
g221 = gate2(184, PIxy[11], PIxy[6], 221, change[11], change[6], change[221]);
g222 = gate2(185, PIxy[12], PIxy[6], 222, change[12], change[6], change[222]);
g223 = gate2(186, PIxy[13], PIxy[6], 223, change[13], change[6], change[223]);
g224 = gate2(187, PIxy[14], PIxy[6], 224, change[14], change[6], change[224]);
g225 = gate2(188, PIxy[15], PIxy[6], 225, change[15], change[6], change[225]);
g226 = gate2(189, 191, 218, 226, change[191], change[218], change[226]);
g227 = gate2(190, 191, 218, 227, change[191], change[218], change[227]);
g228 = gate2(191, 226, 187, 228, change[226], change[187], change[228]);
g229 = gate2(192, 226, 187, POy[6], change[226], change[187], change[229]);
g230 = gate2(193, 227, 228, 230, change[227], change[228], change[230]);
g231 = gate2(194, 196, 219, 231, change[196], change[219], change[231]);
g232 = gate2(195, 196, 219, 232, change[196], change[219], change[232]);
g233 = gate2(196, 231, 192, 233, change[231], change[192], change[233]);
g234 = gate2(197, 231, 192, 234, change[231], change[192], change[234]);
g235 = gate2(198, 232, 233, 235, change[232], change[233], change[235]);
g236 = gate2(199, 201, 220, 236, change[201], change[220], change[236]);
g237 = gate2(200, 201, 220, 237, change[201], change[220], change[237]);
g238 = gate2(201, 236, 197, 238, change[236], change[197], change[238]);
g239 = gate2(202, 236, 197, 239, change[236], change[197], change[239]);
g240 = gate2(203, 237, 238, 240, change[237], change[238], change[240]);
g241 = gate2(204, 206, 221, 241, change[206], change[221], change[241]);
g242 = gate2(205, 206, 221, 242, change[206], change[221], change[242]);
g243 = gate2(206, 241, 202, 243, change[241], change[202], change[243]);
g244 = gate2(207, 241, 202, 244, change[241], change[202], change[244]);
g245 = gate2(208, 242, 243, 245, change[242], change[243], change[245]);
g246 = gate2(209, 211, 222, 246, change[211], change[222], change[246]);
g247 = gate2(210, 211, 222, 247, change[211], change[222], change[247]);
g248 = gate2(211, 246, 207, 248, change[246], change[207], change[248]);
g249 = gate2(212, 246, 207, 249, change[246], change[207], change[249]);
g250 = gate2(213, 247, 248, 250, change[247], change[248], change[250]);
g251 = gate2(214, 216, 223, 251, change[216], change[223], change[251]);
g252 = gate2(215, 216, 223, 252, change[216], change[223], change[252]);
g253 = gate2(216, 251, 212, 253, change[251], change[212], change[253]);
g254 = gate2(217, 251, 212, 254, change[251], change[212], change[254]);
g255 = gate2(218, 252, 253, 255, change[252], change[253], change[255]);
g256 = gate2(219, 182, 224, 256, change[182], change[224], change[256]);
g257 = gate2(220, 182, 224, 257, change[182], change[224], change[257]);
g258 = gate2(221, 256, 217, 258, change[256], change[217], change[258]);
g259 = gate2(222, 256, 217, 259, change[256], change[217], change[259]);
g260 = gate2(223, 257, 258, 260, change[257], change[258], change[260]);
g261 = gate2(224, PIxy[8], PIxy[7], 261, change[8], change[7], change[261]);
g262 = gate2(225, PIxy[9], PIxy[7], 262, change[9], change[7], change[262]);
g263 = gate2(226, PIxy[10], PIxy[7], 263, change[10], change[7], change[263]);
g264 = gate2(227, PIxy[11], PIxy[7], 264, change[11], change[7], change[264]);
g265 = gate2(228, PIxy[12], PIxy[7], 265, change[12], change[7], change[265]);
g266 = gate2(229, PIxy[13], PIxy[7], 266, change[13], change[7], change[266]);
g267 = gate2(230, PIxy[14], PIxy[7], 267, change[14], change[7], change[267]);
g268 = gate2(231, PIxy[15], PIxy[7], 268, change[15], change[7], change[268]);
g269 = gate2(232, 234, 261, 269, change[234], change[261], change[269]);
g270 = gate2(233, 234, 261, 270, change[234], change[261], change[270]);
g271 = gate2(234, 269, 230, 271, change[269], change[230], change[271]);
g272 = gate2(235, 269, 230, POy[7], change[269], change[230], change[272]);
g273 = gate2(236, 270, 271, 273, change[270], change[271], change[273]);
g274 = gate2(237, 239, 262, 274, change[239], change[262], change[274]);
g275 = gate2(238, 239, 262, 275, change[239], change[262], change[275]);
g276 = gate2(239, 274, 235, 276, change[274], change[235], change[276]);
g277 = gate2(240, 274, 235, 277, change[274], change[235], change[277]);
g278 = gate2(241, 275, 276, 278, change[275], change[276], change[278]);
g279 = gate2(242, 244, 263, 279, change[244], change[263], change[279]);
g280 = gate2(243, 244, 263, 280, change[244], change[263], change[280]);
g281 = gate2(244, 279, 240, 281, change[279], change[240], change[281]);
g282 = gate2(245, 279, 240, 282, change[279], change[240], change[282]);
g283 = gate2(246, 280, 281, 283, change[280], change[281], change[283]);
g284 = gate2(247, 249, 264, 284, change[249], change[264], change[284]);
g285 = gate2(248, 249, 264, 285, change[249], change[264], change[285]);
g286 = gate2(249, 284, 245, 286, change[284], change[245], change[286]);
g287 = gate2(250, 284, 245, 287, change[284], change[245], change[287]);
g288 = gate2(251, 285, 286, 288, change[285], change[286], change[288]);
g289 = gate2(252, 254, 265, 289, change[254], change[265], change[289]);
g290 = gate2(253, 254, 265, 290, change[254], change[265], change[290]);
g291 = gate2(254, 289, 250, 291, change[289], change[250], change[291]);
g292 = gate2(255, 289, 250, 292, change[289], change[250], change[292]);
g293 = gate2(256, 290, 291, 293, change[290], change[291], change[293]);
g294 = gate2(257, 259, 266, 294, change[259], change[266], change[294]);
g295 = gate2(258, 259, 266, 295, change[259], change[266], change[295]);
g296 = gate2(259, 294, 255, 296, change[294], change[255], change[296]);
g297 = gate2(260, 294, 255, 297, change[294], change[255], change[297]);
g298 = gate2(261, 295, 296, 298, change[295], change[296], change[298]);
g299 = gate2(262, 225, 267, 299, change[225], change[267], change[299]);
g300 = gate2(263, 225, 267, 300, change[225], change[267], change[300]);
g301 = gate2(264, 299, 260, 301, change[299], change[260], change[301]);
g302 = gate2(265, 299, 260, 302, change[299], change[260], change[302]);
g303 = gate2(266, 300, 301, 303, change[300], change[301], change[303]);
g304 = gate2(267, 277, 273, POy[8], change[277], change[273], change[304]);
g305 = gate2(268, 277, 273, 305, change[277], change[273], change[305]);
g306 = gate2(269, 282, 278, 306, change[282], change[278], change[306]);
g307 = gate2(270, 282, 278, 307, change[282], change[278], change[307]);
g308 = gate2(271, 306, 305, 308, change[306], change[305], change[308]);
g309 = gate2(272, 306, 305, POy[9], change[306], change[305], change[309]);
g310 = gate2(273, 307, 308, 310, change[307], change[308], change[310]);
g311 = gate2(274, 287, 283, 311, change[287], change[283], change[311]);
g312 = gate2(275, 287, 283, 312, change[287], change[283], change[312]);
g313 = gate2(276, 311, 310, 313, change[311], change[310], change[313]);
g314 = gate2(277, 311, 310, POy[10], change[311], change[310], change[314]);
g315 = gate2(278, 312, 313, 315, change[312], change[313], change[315]);
g316 = gate2(279, 292, 288, 316, change[292], change[288], change[316]);
g317 = gate2(280, 292, 288, 317, change[292], change[288], change[317]);
g318 = gate2(281, 316, 315, 318, change[316], change[315], change[318]);
g319 = gate2(282, 316, 315, POy[11], change[316], change[315], change[319]);
g320 = gate2(283, 317, 318, 320, change[317], change[318], change[320]);
g321 = gate2(284, 297, 293, 321, change[297], change[293], change[321]);
g322 = gate2(285, 297, 293, 322, change[297], change[293], change[322]);
g323 = gate2(286, 321, 320, 323, change[321], change[320], change[323]);
g324 = gate2(287, 321, 320, POy[12], change[321], change[320], change[324]);
g325 = gate2(288, 322, 323, 325, change[322], change[323], change[325]);
g326 = gate2(289, 302, 298, 326, change[302], change[298], change[326]);
g327 = gate2(290, 302, 298, 327, change[302], change[298], change[327]);
g328 = gate2(291, 326, 325, 328, change[326], change[325], change[328]);
g329 = gate2(292, 326, 325, POy[13], change[326], change[325], change[329]);
g330 = gate2(293, 327, 328, 330, change[327], change[328], change[330]);
g331 = gate2(294, 268, 303, 331, change[268], change[303], change[331]);
g332 = gate2(295, PIxy[7], 303, 332, change[7], change[303], change[332]);
g333 = gate2(296, 331, 330, 333, change[331], change[330], change[333]);
g334 = gate2(297, 331, 330, POy[14], change[331], change[330], change[334]);
g335 = gate2(298, 332, 333, POy[15], change[332], change[333], change[335]);

// List one or more processes to be composed into a system.
system
synPri,
mul2A, 
mul2Atb,
ediff,
g19,
g20,
g21,
g22,
g23,
g26,
g27,
g28,
g29,
g30,
g31,
g35,
g36,
g37,
g38,
g39,
g40,
g41,
g42,
g43,
g44,
g45,
g47,
g48,
g49,
g50,
g51,
g52,
g53,
g59,
g60,
g64,
g65,
g66,
g67,
g68,
g69,
g70,
g71,
g72,
g73,
g74,
g75,
g76,
g77,
g78,
g79,
g80,
g81,
g82,
g83,
g84,
g85,
g87,
g88,
g89,
g90,
g91,
g92,
g93,
g94,
g95,
g96,
g97,
g98,
g102,
g103,
g104,
g105,
g106,
g107,
g108,
g109,
g110,
g111,
g112,
g113,
g114,
g115,
g116,
g117,
g118,
g119,
g120,
g121,
g122,
g123,
g124,
g125,
g126,
g127,
g128,
g129,
g130,
g131,
g132,
g133,
g134,
g135,
g136,
g137,
g138,
g139,
g140,
g141,
g142,
g143,
g144,
g145,
g146,
g147,
g148,
g149,
g150,
g151,
g152,
g153,
g154,
g155,
g156,
g157,
g158,
g159,
g160,
g161,
g162,
g163,
g164,
g165,
g166,
g167,
g168,
g169,
g170,
g171,
g172,
g173,
g174,
g175,
g176,
g177,
g178,
g179,
g180,
g181,
g182,
g183,
g184,
g185,
g186,
g187,
g188,
g189,
g190,
g191,
g192,
g193,
g194,
g195,
g196,
g197,
g198,
g199,
g200,
g201,
g202,
g203,
g204,
g205,
g206,
g207,
g208,
g209,
g210,
g211,
g212,
g213,
g214,
g215,
g216,
g217,
g218,
g219,
g220,
g221,
g222,
g223,
g224,
g225,
g226,
g227,
g228,
g229,
g230,
g231,
g232,
g233,
g234,
g235,
g236,
g237,
g238,
g239,
g240,
g241,
g242,
g243,
g244,
g245,
g246,
g247,
g248,
g249,
g250,
g251,
g252,
g253,
g254,
g255,
g256,
g257,
g258,
g259,
g260,
g261,
g262,
g263,
g264,
g265,
g266,
g267,
g268,
g269,
g270,
g271,
g272,
g273,
g274,
g275,
g276,
g277,
g278,
g279,
g280,
g281,
g282,
g283,
g284,
g285,
g286,
g287,
g288,
g289,
g290,
g291,
g292,
g293,
g294,
g295,
g296,
g297,
g298,
g299,
g300,
g301,
g302,
g303,
g304,
g305,
g306,
g307,
g308,
g309,
g310,
g311,
g312,
g313,
g314,
g315,
g316,
g317,
g318,
g319,
g320,
g321,
g322,
g323,
g324,
g325,
g326,
g327,
g328,
g329,
g330,
g331,
g332,
g333,
g334,
g335;
</system>
	<queries>
		<query>
			<formula>E[&lt;=25000; 10] (max:mul2Atb.tcover)
			</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=350; 100] (max:bitsCovered)
			</formula>
			<comment/>
		</query>
		<query>
			<formula>Pr[&lt;=25000] (&lt;&gt;bitsCovered&gt;14)
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=350;1] {bits[0], 2+bits[1], 4+bits[2], 6+bits[3], 8+bits[4], 10+bits[5], 12+bits[6], 14+bits[7], bitsCovered, 16+allCovered}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=1250;1] {bits[0], 2+bits[1], 4+bits[2], 6+bits[3], 10+bits[4], 12+bits[5], 14+bits[6], 16+bits[7], 20+bits[8], 22+bits[9], 24+bits[10], 26+bits[11], 28+bits[12], 32+difference, out_sum_all_acc, out_sum_all_approx}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=1500;1] {bits[0], 2+bits[1], 4+bits[2], 6+bits[3], 8+bits[4], 10+bits[5], 12+bits[6], 14+bits[7], 20+bits[8], 22+bits[9], 24+bits[10], 26+bits[11], bitsCovered, 20+allCovered, 30+mul2Atb.inSame, 40+mul2Atb.input, 30+mul2Atb.nsame, mul2Atb.rCover, 60+difference*10}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=2500;5] {100*((((100.0*(out_sum_all_acc-out_sum_all_approx))/(100.0*(out_sum_all_acc+1))))), out_sum_all_acc, out_sum_all_approx}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=2000;5] {40+difference, 50+10*err_magn_v, 100*err_magn_r, out_sum_all_acc, out_sum_all_approx, 80+out_sum_all_diff, mul2Atb.rCover, 100*((1+1.0*out_sum_all_acc)/(1+1.0*out_sum_all_approx))}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=4000;20] {out_sum_all_diff}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=400;5] {bits[0], 2+bits[1], 4+bits[2], 6+bits[3], 10+bits[4], 12+bits[5], 14+bits[6], 16+bits[7], 20+bits[8], 22+bits[9], 24+bits[10], 26+bits[11], 30+bits[14], 32+bits[15], 34+bits[16], 36+bits[13], 38+bits[12], 40+difference, 45+diffctrl, 50+outcnt}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>sup: err_magn_v
			</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=2500; 10] (max:err_magn_v)
			</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=2500; 10] (max:err_magn_r)
			</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=25000; 10] (max:out_sum_all_diff)
			</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=5000;200] {bitsCovered, 100*allCovered, mul2Atb.rCover}
			</formula>
			<comment/>
		</query>
		<query>
			<formula>Pr[&lt;=50000] (&lt;&gt;allCovered)
			</formula>
			<comment/>
		</query>
	</queries>
</nta>
